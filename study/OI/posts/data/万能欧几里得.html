<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>这个目前网上好像没有详细的教程，我来造福社会吧。</p>
<p>为了方便本文的叙述，做一个不严谨的规定。在本文中一个<span
class="math inline">01</span>串可以对应一些信息，并且这些信息是支持合并的，即如果用<span
class="math inline">g(S)</span>表示<span
class="math inline">01</span>串<span
class="math inline">S</span>对应的信息，那么可以用<span
class="math inline">g(S)</span>和<span
class="math inline">g(T)</span>计算出<span
class="math inline">g(S+T)</span>。因此我们不妨类比字符串，将这类信息的合并看作是加法。同样的，这类信息与数字的乘法代表连续的合并。</p>
<p>万能欧几里得可以解决基本所有的类欧几里得问题，而且不同的问题不需要重新推式子，只需要稍作修改即可。</p>
<p>首先来形式化的说明一下万能欧几里得能解决的问题：</p>
<p>给定<span class="math inline">p,q,r,l</span>以及<span
class="math inline">g(&#39;0&#39;)</span>和<span
class="math inline">g(&#39;1&#39;)</span>，并给出一种信息合并的方式满足<span
class="math inline">g(S)+g(T)=g(S+T)</span>。从左至右考虑函数<span
class="math inline">y=\frac{px+r}{q}</span>在<span
class="math inline">(0,l]</span>内的直线并维护一个<span
class="math inline">01</span>字符串<span
class="math inline">S</span>，每当和<span
class="math inline">x=c</span>（<span
class="math inline">c</span>是整数）相交时在<span
class="math inline">S</span>的末尾添加<span
class="math inline">&#39;0&#39;</span>，每当和<span
class="math inline">y=c</span>（<span
class="math inline">c</span>是整数）相交时在<span
class="math inline">S</span>的末尾添加<span
class="math inline">&#39;1&#39;</span>，当经过整点时先添加<span
class="math inline">&#39;1&#39;</span>后添加<span
class="math inline">&#39;0&#39;</span>。求<span
class="math inline">01</span>串<span
class="math inline">S</span>所对应的信息。</p>
<p>可以发现类欧几里得问题都可以转化为上述问题。举个例子，如果我们要求：</p>
<p><span class="math display">
\sum_{i=0}^li\lfloor\frac{pi+r}{q}\rfloor
</span></p>
<p>那么从结果上来讲我们只需要知道每个串对应的<span
class="math inline">\sum
i\lfloor\frac{pi+r}{q}\rfloor</span>，考虑对两个串进行合并，那么对于后面的串来讲<span
class="math inline">\sum
i\lfloor\frac{pi+r}{q}\rfloor</span>就变成了<span
class="math inline">\sum
(i+x)(\lfloor\frac{pi+r}{q}\rfloor+y)</span>，其中<span
class="math inline">x</span>，<span
class="math inline">y</span>分别是前面的串中<span
class="math inline">i</span>和<span
class="math inline">\lfloor\frac{pi+r}{q}\rfloor</span>最终的值。那么显然为了合并<span
class="math inline">x</span>和<span
class="math inline">y</span>也是需要维护的。</p>
<p>进一步考虑<span class="math inline">\sum
(i+x)(\lfloor\frac{pi+r}{q}\rfloor+y)=(\sum
i\lfloor\frac{pi+r}{q}\rfloor)+(x\sum\lfloor\frac{pi+r}{q}\rfloor)+(y\sum
i)+(xy\sum 1)</span>，考虑到<span class="math inline">\sum
i</span>和<span class="math inline">\sum 1</span>都可以由后面的串的<span
class="math inline">x</span>直接得到因此无需维护，只需要再对<span
class="math inline">\sum\lfloor\frac{pi+r}{q}\rfloor</span>进行维护即可。维护的计算方式稍加推导即可得知。</p>
<p>我们将解决上述问题的方法表示为<span
class="math inline">f(p,q,r,l,s_0,s_1)</span>（其中<span
class="math inline">s_0</span>、<span
class="math inline">s_1</span>分别表示<span
class="math inline">g(&#39;0&#39;)</span>、<span
class="math inline">g(&#39;1&#39;)</span>），考虑如何递归至更小的规模：</p>
<p>首先可以发现，我们将<span class="math inline">r</span>对<span
class="math inline">q</span>取余是没有关系的（因为<span
class="math inline">S</span>不会改变），于是可以保证<span
class="math inline">r&lt;q</span>。</p>
<p>接着，如果<span class="math inline">p&lt;q</span>考虑如何转化为<span
class="math inline">p\geq
q</span>。发现这或许可以通过将坐标系的横纵轴翻转解决。我们设<span
class="math inline">k=\lfloor\frac{pl+r}{q}\rfloor</span>，那么可以考虑先处理好值域在<span
class="math inline">(1,k]</span>之间的部分。如果<span
class="math inline">k=0</span>，那么不会经过<span
class="math inline">y=c</span>，我们直接返回<span
class="math inline">s_0*l</span>。否则我们将坐标轴反转并平移，可以使之前的问题等价于函数<span
class="math inline">y=\frac{qx+(q-r)}{p}</span>在<span
class="math inline">(0,k-1]</span>之间的部分，此时我们需要将<span
class="math inline">s_0</span>与<span
class="math inline">s_1</span>互换。不过这里有一个问题是互换了<span
class="math inline">s_0</span>和<span
class="math inline">s_1</span>以后，如果经过了整点那么实际的顺序会与我们规定的相反，为了解决这个问题，我们将函数整体向下平移<span
class="math inline">\frac{1}{p}</span>，即变成<span
class="math inline">y=\frac{qx+(q-r-1)}{p}</span>，那么原来的经过整点就变成了先与<span
class="math inline">x=c</span>相交的情况，和我们期望的一致，并且对其它的经过方式都不会产生结果上的变化。当然这会对头尾的需要单独处理的一小部分产生一些影响，接下来会说明这个问题。现在我们可以递归到<span
class="math inline">f(q,p,q-r-1,s_1,s_0)</span>。</p>
<p>接下来还需要处理首尾的问题。先考虑开头，由于我们已经处理了值域在<span
class="math inline">1</span>之后的，那么与<span
class="math inline">y=c</span>相交的情况只会出现一次，于是我们统计与<span
class="math inline">x=c</span>相交的次数，那么就是函数与<span
class="math inline">y=1</span>相交的点的横坐标的下取整即<span
class="math inline">\lfloor\frac{q-r}{p}\rfloor</span>。不过需要特别注意的是当<span
class="math inline">\frac{q-r}{p}</span>为整数时，我们经过了<span
class="math inline">(1,\frac{q-r}{p})</span>这个整点，而由于我们之前将递归的函数下移了<span
class="math inline">\frac{1}{p}</span>，因此递归的部分实际上会将与<span
class="math inline">x=\frac{q-r}{p}</span>相交的情况包含，因此我们在开头需要计算的与<span
class="math inline">x=c</span>相交的次数只有<span
class="math inline">\lfloor\frac{q-r-1}{p}\rfloor</span>次，之后再与<span
class="math inline">y=1</span>相交。即，在开头需要额外添加的信息是<span
class="math inline">s_0*{\lfloor\frac{q-r-1}{p}\rfloor}+s_1</span>。</p>
<p>尾部的问题也是类似的。由于函数值的整数部分不会再增加，于是只有与<span
class="math inline">x=c</span>相交的情况。计算可得与<span
class="math inline">y=k</span>相交的点横坐标为<span
class="math inline">\frac{kq-r}{p}</span>，由于递归下去的函数平移了<span
class="math inline">\frac{1}{p}</span>因此我们实际上只处理到了<span
class="math inline">\frac{kq-r-1}{p}</span>，于是我们在末尾加上<span
class="math inline">s_0*({l-\lfloor\frac{kq-r-1}{p}\rfloor})</span>即可。</p>
<p>于是我们可以保证<span class="math inline">p\geq
q</span>，考虑怎么解决这一部分。</p>
<p>我们设<span
class="math inline">k=\lfloor\frac{p}{q}\rfloor</span>，那么原函数可以表示为<span
class="math inline">y=kx+\frac{(p\ \bmod\
q)x+r}{q}</span>，将其与函数<span class="math inline">y=\frac{(p\ \bmod\
q)x+r}{q}</span>相比，相当于在每次经过<span
class="math inline">x=c</span>之前额外经过<span
class="math inline">k</span>次<span
class="math inline">y=c</span>。于是我们可以递归至<span
class="math inline">f(p\bmod q,q,r,l,s_1*k+s_0,s_1)</span>。</p>
<p>综上所述，我们完整的解决了万能欧几里得问题。为了使思路更加清晰，我们用伪代码的形式重新整理一遍之前的方法。</p>
<p><span class="math inline">f(p,q,r,l,s_0,s_1)</span> <span
class="math inline">\ \ \ \ r=r\bmod q</span> <span
class="math inline">\ \ \ \ \text{if}\ p&lt;q\ \text{then}</span> <span
class="math inline">\ \ \ \ \ \ \ \
k=\lfloor\frac{pl+r}{q}\rfloor</span> <span class="math inline">\ \ \ \
\ \ \ \ \text{if}\ k=0\ \text{then}</span> <span class="math inline">\ \
\ \ \ \ \ \ \ \ \ \ \text{return}\ s_0*l</span> <span
class="math inline">\ \ \ \ \ \ \ \ \text{return}\
s_0*{\lfloor\frac{q-r-1}{p}\rfloor}+s_1+f(q,p,q-r-1,k-1,s_1,s_0)+s_0*(l-\lfloor\frac{kq-r-1}{p}\rfloor)</span>
<span class="math inline">\ \ \ \ \text{else}</span> <span
class="math inline">\ \ \ \ \ \ \ \ k=\lfloor\frac{p}{q}\rfloor</span>
<span class="math inline">\ \ \ \ \ \ \ \ \text{return}\ f(p\bmod
q,q,r,l,s_1*k+s_0,s_1)</span></p>
<p>如果将维护信息的加法和乘法的复杂度看作<span
class="math inline">O(1)</span>，那么万能欧几里得的复杂度与欧几里得算法的分析相似，为<span
class="math inline">O(\log
n)</span>。值得注意的是通常为了方便乘法可以用倍增进行快速乘，不过如果分析系数与乘数的关系可以得到更快的方法。</p>
<p><span class="math inline">P.S.</span>用平移<span
class="math inline">\frac{1}{p}</span>的方式处理特殊要求的方法是嘿嘿嘿同学告诉我的，嘿嘿嘿太强了。</p>
</body>
</html>
