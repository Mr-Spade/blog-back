<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>啃WC课件系列。</p>
<p>LCA讲得很好了<del>（虽然一些奇怪的定义让人摸不着头脑）</del>，为了以后复习方便自己再整理下。</p>
<p>析合树是用于连续段问题的比较通用的数据结构。</p>
<p>首先定义一下连续段：对于一个长度为<span
class="math inline">n</span>的排列<span
class="math inline">p</span>，如果对于一个区间<span
class="math inline">[l,r]</span>，如果<span
class="math inline">p_l,p_{l+1},\dots,p_r</span>排序后可以组成值域连续的一段，即<span
class="math inline">\max_{i=l}^r p_i-\min_{i=l}^r
p_i+1=r-l+1</span>，那么称<span class="math inline">[l,r]</span>为<span
class="math inline">p</span>的一个连续段。</p>
<p>考虑到连续段有一个非常有用的性质：</p>
<blockquote>
<p>对于两个相交但互不包含的连续段<span
class="math inline">x</span>，<span
class="math inline">y</span>，总有<span class="math inline">x\cup
y</span>、<span class="math inline">x\cap y</span>、<span
class="math inline">x\setminus(x\cap y)</span>和<span
class="math inline">y\setminus(x\cap y)</span>都是连续段。</p>
</blockquote>
<p>证明比较显然。</p>
<p>从这个性质出发，我们定义本原连续段为不存在和它相交且互不包含的其它连续段的连续段。容易发现一个非本原连续段一定可以用若干个相邻的本原连续段的并来表示，并且由于本原连续段互相只有包含关系，因此如果将一个本源连续段看成一个点，那么所有本原连续段实际上可以形成一棵树形结构。非本原连续段都是由某些连续的兄弟本原连续段组成的。</p>
<p>那么，究竟哪些连续的兄弟本原连续段可以组成非本原连续段呢？</p>
<p>由于所有儿子的并是一个连续段，我们不妨将儿子缩成一个点并离散化，这样可以简化为一个排列（不妨叫做儿子排列）。我们只需要知道这个排列的连续段信息即可。</p>
<p>一种合法的情况是，儿子排列的所有非平凡区间都不是连续段，我们将拥有这样的儿子的点成为析点。</p>
<p>接下来考虑至少存在一个非平凡连续段的情况，那么我们枚举所有的非平凡连续段，可以发现所有非平凡连续段的并就是整个排列，同时每一个点都会作为若干个连续段的交出现——否则我们就找到了一个非平凡的本原连续段，这是不可能的。</p>
<p>那么我们可以发现：假设儿子排列的长度为<span
class="math inline">n</span>，那么对于<span class="math inline">1\sim
n-1</span>的每个位置，以它开头的非平凡连续段至少存在一个，对于<span
class="math inline">2\sim
n</span>的每个位置，以它结尾的非平凡连续段也至少存在一个。那我们考虑对于其中的任意一个区间<span
class="math inline">[l,r]</span>，将以<span
class="math inline">l,l+1,\dots,n-1</span>为开头的非平凡连续段取并，可以得到<span
class="math inline">[l,n]</span>是连续段，将以<span
class="math inline">2,3,\dots,r</span>为结尾的非平凡连续段取并，可以得到<span
class="math inline">[1,r]</span>是连续段，将两个连续段取交就可以得到<span
class="math inline">[l,r]</span>也是连续段。</p>
<p>于是我们可以发现这种情况下，任意一个区间都是一个连续段，我们将拥有这样的儿子的点成为合点。同时不难发现合点的儿子排列只可能是<span
class="math inline">1\sim n</span>或者<span class="math inline">n\sim
1</span>。我们将长度为<span
class="math inline">1</span>的连续段也看作合点。</p>
<p>我们还可以发现一些性质：</p>
<p><span
class="math inline">1</span>、对于一个析点，它的儿子个数一定<span
class="math inline">\geq 4</span>，因为<span class="math inline">\leq
3</span>的排列都至少存在一个非平凡连续段。而对于任意<span
class="math inline">n\geq 4</span>，一定存在有<span
class="math inline">n</span>个儿子的析点。因为如果<span
class="math inline">n</span>是偶数，那么<span
class="math inline">2,4,6,\dots,n,1,3,5,\dots,n-1</span>一定是符合要求的排列，否则<span
class="math inline">n</span>是奇数，<span
class="math inline">4,6,8,\dots,n-1,1,3,5,\dots,n,2</span>一定是符合要求的排列。</p>
<p><span class="math inline">2</span>、对于任意一棵包含<span
class="math inline">n</span>个叶子的树，如果指定好每个非叶节点的析合性，并满足析点儿子个数<span
class="math inline">\geq 4</span>，合点儿子个数<span
class="math inline">\geq 2</span>，那么一定存在一个长度为<span
class="math inline">n</span>的排列满足其析合树为这棵树。可以通过构造符合要求的儿子排列实现。</p>
<p><span
class="math inline">3</span>、对于所有区间是否为连续段的情况都相同的排列，它们的析合树相同。结合性质<span
class="math inline">2</span>，我们可以通过计数析合树来计数区间连续段情况的不同个数。</p>
<p>最后的问题是析合树的构造，这里只给出<span class="math inline">O(n\log
n)</span>的做法，LCA的<span
class="math inline">O(n)</span>太强了不会。</p>
<p>考虑增量，在前<span class="math inline">1\sim
i-1</span>项构成的析合树中插入第<span
class="math inline">i</span>项。由于接下来的过程保证只会让已经确定是本原连续段的点向父亲连边，因此可以发现如果一个点已经有父亲则其子树不会再改变（由本原连续段的性质得）。于是我们维护一个栈，表示所有尚未有父亲节点的点。</p>
<p>那么我们描述一下增量第<span
class="math inline">i</span>项的过程：</p>
<p>首先对<span
class="math inline">i</span>单独作为一个点，称为当前点。</p>
<p>接下来不断重复这些步骤：</p>
<p>首先判断一下当前点能否成为栈顶的点的新儿子。如果可以则将当前点的父亲设为栈顶的点，并取出栈顶的点作为新的当前点。不断进行这一步直到栈为空或当前点无法成为栈顶的新儿子。</p>
<p>我们来证明能够合并的当前点一定是一个本原连续段。可以证明栈顶的点一定是合点（因为析点的非平凡儿子前缀一定不是连续段），因此当前点一定是作为儿子排列的最小段或最大段，不妨以是最大段为例，由于之前并未进行合并，因此当前点不存在一个不满的前缀值域是最大段的前缀，等价于不存在一个不满的后缀值域是最大段的后缀。由于最大段的前缀在之前出现过，因此如果想要和当前点的不满后缀拼合得到新的连续段，当前点的后缀的值域必须要是最大段的后缀，而这是不可能的。因此可以合并的当前点一定是本原连续段。</p>
<p>如果当前点不能成为栈顶的儿子，那么先通过某种方法（接下来再具体讲）判断当前点是否可能与栈顶的若干个点合并成一个连续段得到一个新点。如果不可能则直接结束这次增量。否则我们暴力向前扫描直到可以合并成一个连续段为止。</p>
<p>我们来证明合并的这些点一定是本原连续段。可以发现此时“切开”某个儿子的那些前缀的值域不可能是整个连续段值域的前缀（否则会出现新的本原连续段），因此不存在一个切开儿子的后缀是值域的后缀，同理也不存在一个不满的后缀是值域的前缀，因此实际上一个切开儿子的后缀是无法和之后的任何段形成连续段的，可以得证。</p>
<p>考虑除了判断方法之外的部分的复杂度。由于每次花费的时间和栈里减少的元素个数成正比，而每次增量最多使得栈内元素个数<span
class="math inline">+1</span>，因此这部分的复杂度为<span
class="math inline">O(n)</span>。</p>
<p>最后考虑如何判断是否可能与之前的点合并。考虑预处理数组<span
class="math inline">L</span>，其中<span
class="math inline">L_i</span>表示以<span
class="math inline">i</span>右端点的所有连续段的最小左端点。那么加入栈顶的点左端点<span
class="math inline">&lt;L_i</span>，那么一定不会合并。否则如果存在一个点的左端点<span
class="math inline">=L_i</span>，那么一定可以合并到这里。否则一定存在一个不是栈顶的点，其区间为<span
class="math inline">[l,r]</span>且<span class="math inline">l&lt;L_i\leq
r</span>，由连续段性质可知<span
class="math inline">[r+1,i]</span>一定是连续段，因此可以合并。</p>
<p>那么问题在于如何处理<span
class="math inline">L</span>。考虑维护从左到右枚举区间右端点，用线段树维护每个区间的<span
class="math inline">\max-\min+1-区间长度</span>，那么只需要找到一个区间的最左端的值为<span
class="math inline">0</span>的点，由于<span
class="math inline">0</span>是可能的最小值，因此实际上是找到最左边的最小值的位置。考虑对于<span
class="math inline">\max</span>和<span
class="math inline">\min</span>的处理可以用单调栈做到共计<span
class="math inline">O(n)</span>次操作，区间长度也只要在每次右端点更新时更新即可。于是复杂度就是<span
class="math inline">O(n\log n)</span>。</p>
<p>综上所述，构建析合树的复杂度可以做到<span class="math inline">O(n\log
n)</span>。</p>
<p><span
class="math inline">P.S.</span>文章里许多过程或者证明都是我口胡的，假如存在错误或者不必要的繁琐的地方恳请指正。</p>
</body>
</html>
