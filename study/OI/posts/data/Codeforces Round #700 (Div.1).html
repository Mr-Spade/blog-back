<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>上红成功。</p>
<h2 id="a.searching-local-minimum">A.Searching Local Minimum</h2>
<p>题意：交互题，事先确定一个长度为<span
class="math inline">n</span>的排列，可以询问不超过<span
class="math inline">100</span>次某位置的值，最终给出一个位置，满足两边相邻的元素值（如果存在）都大于这一位置的元素。
<span class="math inline">n\leq 10^5</span></p>
<p>题解：小范围暴力。否则考虑询问<span
class="math inline">1,2,n-1,n</span>的位置，判断<span
class="math inline">1</span>和<span
class="math inline">n</span>位置是否满足条件。</p>
<p>如果都不满足条件，可以证明可以从中选出三个数<span
class="math inline">x,y,z</span>满足<span
class="math inline">x&lt;y&lt;z</span>且<span
class="math inline">a_x&gt;a_y,a_z&gt;a_y</span>。考虑不断缩小三元组的值的距离。迭代，取<span
class="math inline">y-x</span>和<span
class="math inline">z-y</span>中较大者，假设为<span
class="math inline">y-x</span>，那么询问<span
class="math inline">t=\lfloor\frac{x+y}{2}\rfloor</span>处的值，比较其和<span
class="math inline">a_y</span>的大小，<span
class="math inline">a_t&lt;a_y</span>则<span
class="math inline">(x,y,z)\to (x,t,y)</span>，否则<span
class="math inline">(x,y,z)\to (t,y,z)</span>，可以证明这样迭代会以<span
class="math inline">O(\log n)</span>的复杂度得到符合条件的一个位置。</p>
<h2 id="b1b2.painting-the-array">B1/B2.Painting the Array</h2>
<p>题意：将长度为<span
class="math inline">n</span>的数组划分为两个数组，满足归并后为原数组，且两数组不同颜色连续段个数之和最大/最小。
<span class="math inline">1\leq n\leq 10^5</span></p>
<p>题解：其实有一个统一的做法：暴力dp，设考虑前<span
class="math inline">i</span>个位置，两段末尾的颜色分别为<span
class="math inline">a</span>和<span
class="math inline">b</span>的答案的最大/最小值为<span
class="math inline">f_{i,a,b}</span>。由于第<span
class="math inline">i</span>个元素一定在某一个数组的末尾，因此其实颜色<span
class="math inline">a</span>是确定的，可以用一棵线段树维护以<span
class="math inline">b</span>为下标的<span
class="math inline">f_i</span>数组，转移到<span
class="math inline">i+1</span>，分为加入<span
class="math inline">a</span>之后和加入<span
class="math inline">b</span>之后讨论：如果加入<span
class="math inline">a</span>之后，<span
class="math inline">b</span>下标不变，若<span
class="math inline">i</span>与<span
class="math inline">i+1</span>颜色不同，数组全体增加<span
class="math inline">1</span>；如果加入<span
class="math inline">b</span>之后，一定更新下标为<span
class="math inline">i</span>的颜色的位置，讨论之前的<span
class="math inline">b</span>的颜色和<span
class="math inline">i+1</span>是否相同，分区间查询线段树的最值即可更新答案。总复杂度<span
class="math inline">O(n\log n)</span>。</p>
<h2 id="c.continuous-city">C.Continuous City</h2>
<p>题意：构造一张不超过<span
class="math inline">32</span>个点的正边权简单DAG，满足<span
class="math inline">1</span>到<span
class="math inline">n</span>长度为<span
class="math inline">x</span>的路径恰好有一条，<span
class="math inline">x=L,L+1,\dots,R</span>。</p>
<p><span class="math inline">L,R\leq 10^6</span></p>
<p>题解：考虑递归，<span
class="math inline">L=R</span>直接连边，否则令<span
class="math inline">mid=\lfloor\frac{L+R+1}{2}\rfloor-1</span>，先构造关于<span
class="math inline">[L,mid]</span>的图，设终点为<span
class="math inline">t</span>，新建一个复制点<span
class="math inline">t&#39;</span>，将<span
class="math inline">t</span>的入边复制一遍，再由<span
class="math inline">t&#39;</span>向<span
class="math inline">t</span>连一条长度为<span
class="math inline">mid+1-L</span>的边，此时，点<span
class="math inline">t</span>已经对区间<span
class="math inline">[L,R-((R-L+1)\bmod 2)]</span>满足题目条件，若<span
class="math inline">R-L+1</span>是奇数，则额外新建一个工具点<span
class="math inline">t&#39;&#39;</span>，构造一条<span
class="math inline">1\to t&#39;&#39;\to t</span>的长度为<span
class="math inline">R</span>的路径即可。可以证明点数是<span
class="math inline">O(\log R)</span>的。</p>
<h2 id="d.odd-mineral-resource">D.Odd Mineral Resource</h2>
<p>考场上最后一分钟交题被卡常了…不爽</p>
<p>题意：一棵大小为<span class="math inline">n</span>的带点权的树，<span
class="math inline">q</span>次询问，每次问<span
class="math inline">u</span>到<span
class="math inline">v</span>的路径上，是否存在<span
class="math inline">[l,r]</span>中的权值，在路径上出现奇数次，如果有输出任意一个。</p>
<p><span class="math inline">n,q\leq 3*10^5</span></p>
<p>题解： 考虑判断一个询问是否存在<span
class="math inline">[l,r]</span>之间的答案：对<span
class="math inline">[l,r]</span>中的每个数随机分配一个权值，计算<span
class="math inline">u</span>到<span
class="math inline">v</span>的路径点权值异或和是否为<span
class="math inline">0</span>即可。 因此类似于整体二分，先将<span
class="math inline">q</span>个询问用线段树规则拆分成<span
class="math inline">O(\log
n)</span>个询问插入二分过程中。现在询问的答案在<span
class="math inline">[l,r]</span>之间，队列中有权值为<span
class="math inline">[l,r]</span>的点和待回答的答案在这个区间内的询问。由于有中途插入的询问，先判断一遍是否在<span
class="math inline">[l,r]</span>有解。接下来取<span
class="math inline">mid=\lfloor\frac{l+r}{2}\rfloor</span>，判断每个有解询问是否在<span
class="math inline">[l,mid]</span>中仍然有解，如有分在左半部分，否则在右半部分，点则按照权值分在两部分，递归进行即可。</p>
<p>分析复杂度，假设某一过程有<span
class="math inline">k</span>个操作，利用树状数组+lca统计路径异或和，复杂度为<span
class="math inline">O(k\log n)</span>，每个点操作会被执行<span
class="math inline">O(\log n)</span>次，每个询问会先被拆分为<span
class="math inline">O(\log n)</span>个，拆分后每个询问又最多递归<span
class="math inline">O(\log
n)</span>次。但这里有一个优化：初步拆分的<span
class="math inline">O(\log
n)</span>个询问，可以先判断一遍是否有解，选取一个有解的继续递归<span
class="math inline">O(\log n)</span>次寻找答案即可。于是总复杂度是<span
class="math inline">O(n\log ^2n)</span>。</p>
<h2 id="e.school-clubs">E.School Clubs</h2>
<p>题意：有<span class="math inline">n</span>个人，每个人恰好属于<span
class="math inline">m</span>个俱乐部中的一个，每轮随机选一个人，<span
class="math inline">\frac{1}{2}</span>的概率令其单独成立一个新俱乐部（只有一个人），<span
class="math inline">\frac{1}{2}</span>的概率从已有俱乐部中随机选一个加入，对于此人离开前人数为<span
class="math inline">a</span>的俱乐部，其被选择的概率为<span
class="math inline">\frac{a}{n}</span>。求所有人都在一个俱乐部内的期望时间。</p>
<p>题解：这是一个期望停时问题，可以通过建立一个势函数来解决。解决方法见<a
href="https://www.cnblogs.com/TinyWong/p/12887591.html">出题人的blog</a>。
假设现在的俱乐部人数可以用一个可重集<span
class="math inline">A</span>表示，根据信仰，我们认为存在一个合法的势函数可以写成如下形式：</p>
<p><span class="math display">
\phi(A)=\sum_{a\in A}f(a)
</span></p>
<p>那么由停时定理，问题转化为求<span
class="math inline">\sum_if(a_i)-f(n)</span>，其中<span
class="math inline">a_i</span>表示初始时刻第<span
class="math inline">i</span>个俱乐部的人数。现在关注如何求解<span
class="math inline">f</span>。</p>
<p>首先，由于添加若干个人数为<span
class="math inline">0</span>的俱乐部没有影响，一定有<span
class="math inline">f(0)=0</span>。</p>
<p>那么为了满足<span class="math inline">\mathbb{E}[
\phi(A_{t+1})-\phi(A_t) \mid A_t, A_{t-1}, \dots, A_1, A_0 ]=\mathbb{E}[
\phi(A_{t+1})-\phi(A_t) \mid A_t]=-1</span>，根据题目的转移规律有：</p>
<p><span class="math display">
\mathbb{E}[ \phi(A_{t+1})-\phi(A_t) \mid A_t]
</span></p>
<p><span class="math display">
=\sum_{a\in
A}\frac{a}{n}\Bigg(\frac{1}{2}\Big(\phi(A_k)-f(a)+f(a-1)+f(1)\Big)+\frac{a}{2n}\phi(A_k)+\frac{1}{2}\sum_{b\in
A,b\not\equiv
a}\frac{b}{n}\Big(\phi(A_k)-f(a)+f(a-1)-f(b)+f(b+1)\Big)\Bigg)-\phi(A_t)
</span></p>
<p><span class="math display">
=\frac{1}{2}\Bigg(f(1)+\sum_{a\in
A}\frac{a}{n}\bigg(\Big(2-\frac{a}{n}\Big)\Big(f(a-1)-f(a)\Big)+\Big(1-\frac{a}{n}\Big)\Big(f(a+1)-f(a)\Big)\bigg)\Bigg)
</span></p>
<p><span class="math display">
=-1
</span></p>
<p>由<span class="math inline">A</span>的任意性，可得<span
class="math inline">\frac{1}{2}f(1)=-1</span>，于是<span
class="math inline">f(1)=-2</span> ，于是：</p>
<p><span class="math display">
\Big(2-\frac{a}{n}\Big)\Big(f(a-1)-f(a)\Big)+\Big(1-\frac{a}{n}\Big)\Big(f(a+1)-f(a)\Big)=0
</span></p>
<p>令<span class="math inline">g(a)=\Delta
f(a)=f(a+1)-f(a)</span>，转化得：</p>
<p><span class="math display">
\frac{g(a)}{g(a-1)}=\frac{2n-a}{n-a}
</span></p>
<p><span class="math display">
g(a)=g(0)\prod_{i=1}^a\frac{g(i)}{g(i-1)}=-2\prod_{i=1}^a\frac{2n-i}{n-i}
</span></p>
<p>可以验证：</p>
<p><span class="math display">
f(a)=f(0)+\sum_{i=0}^{a-1}g(i)=-2\sum_{i=0}^{a-1}\prod_{j=1}^i\frac{2n-j}{n-j}=-2\frac{n}{n-1}\Big(\prod_{i=1}^a\frac{2n-i}{n+1-i}-1\Big)
</span></p>
<p>于是：</p>
<p><span class="math display">
f(a)=-2\frac{n}{n-1}\Big(\prod_{i=1}^a\frac{2n-i}{n+1-i}-1\Big)\tag{1}
</span></p>
<p><span class="math display">
=-2\frac{n}{n-1}\Big(\frac{(2n-1)!(n-a)!}{(2n-a-1)!n!}-1\Big)\tag{2}
</span></p>
<p>接下来的处理和<a
href="https://www.cnblogs.com/Mr-Spade/p/10166891.html">鬼牌</a>类似，设阈值<span
class="math inline">T</span>，对于<span
class="math inline">a_1,a_2,\dots,a_m</span>，分为<span
class="math inline">\leq T</span>和<span
class="math inline">&gt;T</span>两部分。<span class="math inline">\leq
T</span>的部分，由<span class="math inline">(1)</span>式通过<span
class="math inline">O(T+m\log \rm{MOD})</span>的复杂度递推求解；<span
class="math inline">&gt;T</span>的部分不超过<span
class="math inline">\frac{n}{T}</span>个，利用<span
class="math inline">(2)</span>式配合分段打表求阶乘解决，假设打表间隔为<span
class="math inline">T&#39;</span>，这一部分的复杂度就是<span
class="math inline">O(\frac{n}{T}T&#39;)</span>。</p>
<p>综上所述，解决问题的时间复杂度为<span
class="math inline">O(T+\frac{n}{T}T&#39;+m\log
\rm{MOD})</span>，考虑到打表，空间复杂度为<span
class="math inline">O(m+\frac{n}{T&#39;})</span>。可以取<span
class="math inline">T=10^7,T&#39;=2*10^5</span>（CF的代码长度限制为65535B）。</p>
</body>
</html>
