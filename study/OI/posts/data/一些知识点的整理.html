<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h3 id="onlog-n求通常幂多项式的不定和式"><span
class="math inline">O(n\log n)</span>求通常幂多项式的不定和式</h3>
<p>即给定多项式<span
class="math inline">\sum_{k=0}^{n-1}a_kx^k</span>，求<span
class="math inline">\sum_{k=0}^{n-1}a_kS_k(x)</span>的系数。其中<span
class="math inline">S_k(x)=\sum_{i=0}^{x-1}i^k</span>。</p>
<p>考虑从奇怪的角度出发：</p>
<p><span class="math display">
n^k=k![x^k]e^{nx}
</span></p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k![x^k]\Big(\sum_{i=0}^{n-1}e^{ix}\Big)
</span></p>
<p>其中<span
class="math inline">\sum_{i=0}^{n-1}e^{ix}</span>可以用等比数列求和公式简化为<span
class="math inline">\frac{e^{nx}-1}{e^x-1}</span>。发现分母和求和指标<span
class="math inline">i</span>是无关的，我们尝试将其分离。但是由于<span
class="math inline">e^x-1</span>常数项为<span
class="math inline">0</span>无法直接分离，所以我们考虑在等式右边乘以<span
class="math inline">x</span>，将<span
class="math inline">\frac{x}{e^x-1}</span>分离。即：</p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k![x^k]\frac{e^{nx}-1}{e^x-1}
</span></p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k![x^{k+1}]\frac{x(e^{nx}-1)}{e^x-1}
</span></p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k![x^{k+1}]\bigg(\frac{x}{e^x-1}(e^{nx}-1)\bigg)
</span></p>
<p>实际上<span
class="math inline">\frac{x}{e^x-1}</span>就是伯努利数的指数生成函数，我们将其简记为<span
class="math inline">B</span>。</p>
<p>那么我们直接展开两个多项式相乘的系数，可以得到：</p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k!\sum_{j=0}^{k+1}B_{k+1-j}[x^j](e^{nx}-1)
</span></p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k!\sum_{j=1}^{k+1}B_{k+1-j}[x^j]e^{nx}
</span></p>
<p><span class="math display">
\sum_{i=0}^{n-1}i^k=k!\sum_{j=1}^{k+1}B_{k+1-j}\frac{n^j}{j!}
</span></p>
<p>于是可以得到：</p>
<p><span class="math display">
\sum_{i=0}^{x-1}i^k=k!\sum_{j=1}^{k+1}B_{k+1-j}\frac{x^j}{j!}
</span></p>
<p>回代到原式可得：</p>
<p><span class="math display">
\sum_{k=0}^{n-1}a_kS_k(x)=\sum_{k=0}^{n-1}a_kk!\Big(\sum_{j=1}^{k+1}B_{k+1-j}\frac{x^j}{j!}\Big)
</span></p>
<p><span class="math display">
=\sum_{j=1}^nx^j\frac{1}{j!}\Big(\sum_{k=j-1}^{n-1}a_kk!B_{k+1-j}\Big)
</span></p>
<p>直接进行卷积即可。</p>
<p>板子题：<a
href="https://www.luogu.org/problemnew/show/P3711">洛谷P3711</a>。</p>
<h3 id="点分治中降低复杂度的一种方法">点分治中降低复杂度的一种方法</h3>
<p>有时点分治的过程要求我们求出从分治部分的根到重心的信息，如果直接做通常会成为复杂度瓶颈，使复杂度多一个<span
class="math inline">\log</span>之类的。但是考虑到在递归至子树的时候我们已经做了一部分这样的问题了，我们也许可以利用这些结果来降低复杂度。设重心为<span
class="math inline">x</span>，考虑从重心的父亲<span
class="math inline">y</span>开始统计，可以发现<span
class="math inline">y</span>到划分给<span
class="math inline">y</span>的连通块的根<span
class="math inline">z</span>的这段路径已经统计好了，结果直接利用，但此时由于<span
class="math inline">z</span>被<span
class="math inline">y</span>递归求解了因此<span
class="math inline">z</span>本身并没有存下更远的路径的信息。但是<span
class="math inline">z</span>的父亲一定是离<span
class="math inline">y</span>最近的既是<span
class="math inline">y</span>的祖先又是点分树上<span
class="math inline">y</span>的祖先的点，于是它一定统计了更远的路径，并且它负责的连通块<span
class="math inline">size</span>至少是<span
class="math inline">y</span>的两倍。于是我们在目前的基础上添加<span
class="math inline">z</span>到<span
class="math inline">z</span>的父亲的信息以及<span
class="math inline">z</span>的父亲到所属连通块的根的信息即可。我们可以不断合并这些信息直到到达<span
class="math inline">x</span>的根为止。</p>
<p>详情可以见例题<a href="http://uoj.ac/problem/23">UOJ
#23</a>，只不过这道题是仙人掌，可能有些丑陋。其实thusc2018有一道更好的题，可以用点分治加上面的技巧在<span
class="math inline">O(n\log^2n)</span>的时间内解决（不用这个方法则是<span
class="math inline">O(n\log^3n)</span>的），做到了和标算一样的复杂度。有兴趣的可以上网搜一搜题目。</p>
<h3
id="最小割的一种建图方法和个人理解">最小割的一种建图方法和个人理解</h3>
<p>最小割模型中一条<span class="math inline">S\to
T</span>的路径上的边可能会被割大于一条的数量，如果想要限制这条路径最多只割一条边，可以给这条路径加上容量为<span
class="math inline">\infty</span>的反向弧。</p>
<p>个人感觉最小割其实是在做一种类似<span
class="math inline">2-SAT</span>的问题，只不过最小割可以求出代价最小的一种方案（<span
class="math inline">2-SAT</span>的代价只能是<span
class="math inline">\infty</span>），但不可以支持两个条件同时为真/假时需要付出代价的限制（但如果这类代价只会在两个不交的集合之间发生显然可以黑白染色后再用最小割做）。所以假如你感觉题目是在让你求一个有代价的<span
class="math inline">2-SAT</span>问题，而数据范围又不大的时候，基本可以往最小割方向想了。</p>
<h3
id="一种吊打cdq分治的离线统计法">一种吊打（？）cdq分治的离线统计法</h3>
<p>cdq分治可以用于解决一类“贡献独立，允许离线”的统计性问题。主要思想是通过对时间分治消除时间的影响，只需静态的统计前半部分的插入对后半部分询问的影响就可以了。不过，对于同样贡献独立，但是允许删除的问题，cdq分治有时就会失效。但是此时我们可以考虑更换一种分组统计的方法，建立时间线段树。此时一个插入操作对一段区间有效。对于时间线段树上的每个节点，我们静态统计包含这个区间的所有插入操作对这个区间中的询问的贡献。这样我们就可以支持删除操作，复杂度和cdq分治还是一样的。</p>
<h3 id="图的四元环计数">图的四元环计数</h3>
<p>当然由于数量很多肯定是不能随心所欲的计数的。通常四元环的贡献是边权的乘积，就以这个为例。可以像三元环计数一样，枚举所有<span
class="math inline">x\to y\to z</span>的路径。我们在<span
class="math inline">z</span>中记录当前所有不同的<span
class="math inline">y</span>的<span class="math inline">x\to y\to
z</span>的路径的权值和，在又一次枚举到<span
class="math inline">z</span>的时候将贡献相乘统计进答案里就可以了。复杂度也是<span
class="math inline">O(m\sqrt m)</span>的。</p>
<h3
id="利用四毛子优化常数时间复杂度">利用四毛子优化<del>常数</del>时间复杂度</h3>
<p>有时候我们对一个对象计算答案的时候需要递归到更小的情况，这样的复杂度可能稍微超出限制。但是考虑到递归至极小的情况（比如<span
class="math inline">O(\log
n)</span>的级别）的时候本质不同的情况不会很多，我们可以预处理它们以直接获得答案，减少递归次数。</p>
<p>通常可以令复杂度除以<span class="math inline">\log</span>。</p>
</body>
</html>
