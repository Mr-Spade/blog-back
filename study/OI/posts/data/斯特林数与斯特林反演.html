<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>此文章重构于<span class="math inline">2019.2.26</span>。</p>
<p>斯特林数分为第一类斯特林数和第二类斯特林数，其形式与二项式系数很相似。斯特林数在下降幂与通常幂的变换中也有重要作用。</p>
<h3 id="第一类斯特林数">第一类斯特林数</h3>
<h5 id="定义">定义</h5>
<p>我们将把<span class="math inline">n</span>个不同元素分成<span
class="math inline">k</span>个非空圆排列的方案数记为<span
class="math inline">\begin{bmatrix}n\\
k\end{bmatrix}</span>，两种方案不同当且仅当存在一个圆排列仅在其中一种方案中出现。所有形如<span
class="math inline">\begin{bmatrix}n\\
k\end{bmatrix}</span>都叫做第一类斯特林数，在某些地方第一类斯特林数也被记为<span
class="math inline">s_n^k</span>。</p>
<h5 id="递推式">递推式</h5>
<p>考虑如何对第一类斯特林数进行递推。类似二项式系数的递推，我们对于第<span
class="math inline">n</span>个元素是否单独组成一个圆排列进行分类讨论。如果其单独组成一个圆排列，那么这种情况的方案数显然为<span
class="math inline">\begin{bmatrix}n-1\\
k-1\end{bmatrix}</span>，否则我们将第<span
class="math inline">n</span>个元素插入已有的圆排列中，显然一共存在<span
class="math inline">n-1</span>个本质不同的位置，于是这种情况的方案数就为<span
class="math inline">(n-1)\begin{bmatrix}n-1\\
k\end{bmatrix}</span>。于是我们可以得到一个形式优美的递推式：</p>
<p><span class="math display">
\begin{bmatrix}n\\ k\end{bmatrix}=\begin{bmatrix}n-1\\
k-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\ k\end{bmatrix}
</span></p>
<h5 id="通项公式">通项公式</h5>
<p>很遗憾，第一类斯特林数不存在比较简洁的通项公式。</p>
<h5 id="生成函数">生成函数</h5>
<p>虽然通项公式并不存在简洁形式，但是其生成函数或许是非常优美的。</p>
<p>我们按行分开考虑，记<span class="math inline">f_n</span>为第<span
class="math inline">n</span>行的生成函数，即<span
class="math inline">f_n=\sum_{i=0}^n\begin{bmatrix}n\\
i\end{bmatrix}x^i</span>，从递推式中不难发现<span
class="math inline">f_{n+1}</span>与<span
class="math inline">f_n</span>的关系即为：</p>
<p><span class="math display">
f_{n+1}=(x+n)*f_n
</span></p>
<p>于是我们可以得到优美的生成函数：</p>
<p><span class="math display">
f_n=\prod_{i=0}^{n-1}(x+i)=x^{\overline n}
</span></p>
<h5 id="求法">求法</h5>
<p>通过递推式，我们可以在<span
class="math inline">O(nk)</span>的时间内求出<span
class="math inline">\begin{bmatrix}n\\
k\end{bmatrix}</span>，但我们有更快的方法。</p>
<p>考虑从生成函数出发如何快速求出第<span
class="math inline">n</span>行的所有第一类斯特林数。不难发现上式可以简单的通过分治<span
class="math inline">\text{FFT}</span>在<span
class="math inline">O(n\log^2
n)</span>的时间内求出。不过考虑到式子的特殊性，我们可以找到更快的方法：</p>
<p>通过上升幂的性质，我们有：</p>
<p><span class="math display">
x^{\overline {2k}}=x^{\overline k}*(x+k)^{\overline k}
</span></p>
<p>考虑如何快速求<span class="math inline">(x+k)^{\overline
k}</span>：</p>
<p><span class="math display">
(x+k)^{\overline k}=\sum_{i=0}^k \begin{bmatrix}k\\
i\end{bmatrix}(x+k)^i
</span> <span class="math display">
=\sum_{i=0}^k \begin{bmatrix}k\\ i\end{bmatrix}
\Big(\sum_{j=0}^i{i\choose j}x^jk^{i-j}\Big)
</span></p>
<p><span class="math display">
=\sum_{j=0}^kx^j\Big(\sum_{i=j}^k\begin{bmatrix}k\\
i\end{bmatrix}{i\choose j}k^{i-j}\Big)
</span></p>
<p><span class="math display">
=\sum_{j=0}^k\frac{x^j}{j!}\Big(\sum_{i=j}^k (\begin{bmatrix}k\\
i\end{bmatrix}*i!)*\frac{k^{i-j}}{(i-j)!}\Big)
</span></p>
<p>不难发现上式其实是一个卷积，于是我们可以在<span
class="math inline">O(n\log n)</span>的时间内从<span
class="math inline">x^{\overline k}</span>倍增到<span
class="math inline">x^{\overline {2k}}</span>，也可以很快的从<span
class="math inline">x^{\overline {2k}}</span>推到<span
class="math inline">x^{\overline
{2k+1}}</span>，于是进行与多项式倍增类似的操作，我们可以在<span
class="math inline">O(n\log n)</span>的时间内求出所有第<span
class="math inline">n</span>行的第一类斯特林数。</p>
<h5 id="一些性质">一些性质</h5>
<p>通过生成函数我们可以发现第一类斯特林数实际上可以代表从上升幂到通常幂的变换，即：</p>
<p><span class="math display">
x^{\overline n}=\sum_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}x^i
</span></p>
<p>通过<span
class="math inline">\prod_{i=0}^{n-1}(x+i)</span>转化为<span
class="math inline">\prod_{i=0}^{n-1}(x-i)</span>我们可以将上升幂转化为更常用的下降幂，不难发现此时第一类斯特林数需要带上符号：</p>
<p><span class="math display">
x^{\underline n}=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n\\
i\end{bmatrix}x^i
</span></p>
<h3 id="第二类斯特林数">第二类斯特林数</h3>
<h5 id="定义-1">定义</h5>
<p>我们将把<span class="math inline">n</span>个不同元素分成<span
class="math inline">k</span>个非空集合的方案数记为<span
class="math inline">\begin{Bmatrix}n\\
k\end{Bmatrix}</span>，两种方案不同当且仅当存在一个集合仅在其中一种方案中出现。所有形如<span
class="math inline">\begin{Bmatrix}n\\
k\end{Bmatrix}</span>都叫做第二类斯特林数，在某些地方第二类斯特林数也被记为<span
class="math inline">S_n^k</span>。</p>
<h5 id="递推式-1">递推式</h5>
<p>考虑如何对第二类斯特林数进行递推。类似二项式系数的递推，我们对于第<span
class="math inline">n</span>个元素是否单独组成一个集合进行分类讨论。如果其单独组成一个集合，那么这种情况的方案数显然为<span
class="math inline">\begin{Bmatrix}n-1\\
k-1\end{Bmatrix}</span>，否则我们将第<span
class="math inline">n</span>个元素插入已有的集合中，显然一共存在<span
class="math inline">k</span>个本质不同的位置，于是这种情况的方案数就为<span
class="math inline">k\begin{Bmatrix}n-1\\
k\end{Bmatrix}</span>。于是我们可以得到一个形式优美的递推式：</p>
<p><span class="math display">
\begin{Bmatrix}n\\ k\end{Bmatrix}=\begin{Bmatrix}n-1\\
k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\ k\end{Bmatrix}
</span></p>
<h5 id="通项公式-1">通项公式</h5>
<p>幸运的是第二类斯特林数存在一个比较简洁的通项公式。</p>
<p>我们考虑将<span class="math inline">n</span>个元素划分为<span
class="math inline">k</span>个<strong>不同</strong>的非空集合的方案数，容易发现由于元素互不相同且每个集合是非空的，所以集合也是互不相同的，因此方案数就是<span
class="math inline">\begin{Bmatrix}n\\ k\end{Bmatrix}*k!</span>。</p>
<p>再考虑将<span class="math inline">n</span>个元素划分为<span
class="math inline">k</span>个<strong>不同</strong>的可空集合的方案数，显然是枚举每个元素放入哪个集合，方案数就是<span
class="math inline">k^n</span>。</p>
<p>考虑这两种方案之间的关系，对于划分为可空集合，我们可以通过枚举有几个集合是非空的从而得到下面这个等式：</p>
<p><span class="math display">
k^n=\sum_{i=0}^k{k\choose i}\begin{Bmatrix}n\\ i\end{Bmatrix}*i!
</span></p>
<p>显然这是一个二项式反演的形式，对其进行二项式反演可以得到：</p>
<p><span class="math display">
\begin{Bmatrix}n\\
k\end{Bmatrix}=\frac{1}{k!}\Big(\sum_{i=0}^k(-1)^{k-i}{k\choose
i}i^n\Big)
</span></p>
<h5 id="生成函数-1">生成函数</h5>
<p>通过通项公式，我们容易发现其生成函数的形式。考虑对通项公式进行转化：</p>
<p><span class="math display">
\begin{Bmatrix}n\\
k\end{Bmatrix}=\frac{1}{k!}\Big(\sum_{i=0}^k(-1)^{k-i}{k\choose
i}i^n\Big)
</span></p>
<p><span class="math display">
=\sum_{i=0}^k\frac{(-1)^{k-i}}{(k-i)!}*\frac{i^n}{i!}
</span></p>
<p>那么我们记<span class="math inline">f_n=\sum_{i\geq
0}\begin{Bmatrix}n\\ i\end{Bmatrix}x^i</span>，<span
class="math inline">g_n=\sum_{i\geq
0}\frac{i^n}{i!}x^i</span>，可以得到：</p>
<p><span class="math display">
f_n=e^{-x}*g_n
</span></p>
<h5 id="求法-1">求法</h5>
<p>通过递推式，我们可以在<span
class="math inline">O(nk)</span>的时间内求出<span
class="math inline">\begin{Bmatrix}n\\
k\end{Bmatrix}</span>，但我们有更快的方法。</p>
<p>直接通过生成函数，我们就得到了<span class="math inline">O(n\log
n)</span>求第<span
class="math inline">n</span>行所有第二类斯特林数的方法。</p>
<h5 id="一些性质-1">一些性质</h5>
<p>第二类斯特林数与幂和下降幂也有关系，但是并不如第一类斯特林数那么显然。我们尝试用归纳法证明：</p>
<p><span class="math display">
x^n=\sum_{i=0}^n \begin{Bmatrix}n\\ i\end{Bmatrix}x^{\underline i}
</span></p>
<p>在<span class="math inline">n=0</span>时显然成立，考虑当<span
class="math inline">n-1</span>时成立如何推导<span
class="math inline">n</span>时也成立:</p>
<p><span class="math display">
x^n=x*x^{n-1}=\sum_{i=0}^{n-1} \begin{Bmatrix}n-1\\ i\end{Bmatrix}
x*x^{\underline i}
</span></p>
<p>我们考虑到<span class="math inline">x*x^{\underline
i}=i*x^{\underline i}+(x-i)*x^{\underline i}=i*x^{\underline
i}+x^{\underline {i+1}}</span>，于是有：</p>
<p><span class="math display">
\sum_{i=0}^{n-1} \begin{Bmatrix}n-1\\ i\end{Bmatrix} x*x^{\underline
i}=\sum_{i=0}^{n-1}i\begin{Bmatrix}n-1\\ i\end{Bmatrix}x^{\underline
i}+\begin{Bmatrix}n-1\\ i\end{Bmatrix}x^{\underline {i+1}}
</span></p>
<p><span class="math display">
=\sum_{i=0}^n (\begin{Bmatrix}n-1\\
i-1\end{Bmatrix}+i\begin{Bmatrix}n-1\\ i\end{Bmatrix})x^{\underline i}
</span></p>
<p><span class="math display">
=\sum_{i=0}^n \begin{Bmatrix}n\\ i\end{Bmatrix} x^{\underline i}
</span></p>
<p>以上可知证毕。</p>
<p>类似的，我们也有关于上升幂的式子：</p>
<p><span class="math display">
x^n=\sum_{i=0}^n(-1)^{n-i}\begin{Bmatrix}n\\ i\end{Bmatrix} x^{\overline
i}
</span></p>
<h3 id="斯特林反演">斯特林反演</h3>
<p>我们已经得到两个形式优美的式子：</p>
<p><span class="math display">
x^{\underline n}=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n\\
i\end{bmatrix}x^i
</span></p>
<p><span class="math display">
x^n=\sum_{i=0}^n \begin{Bmatrix}n\\ i\end{Bmatrix} x^{\underline i}
</span></p>
<p>我们可以把两个式子组合一下：</p>
<p><span class="math display">
x^{\underline n}=\sum_{i=0}^n (-1)^{n-i}\begin{bmatrix}n\\
i\end{bmatrix} x^i
</span></p>
<p><span class="math display">
=\sum_{i=0}^n (-1)^{n-i}\begin{bmatrix}n\\ i\end{bmatrix}
\Big(\sum_{j=0}^i\begin{Bmatrix}i\\ j\end{Bmatrix}x^{\underline j}\Big)
</span></p>
<p><span class="math display">
=\sum_{j=0}^nx^{\underline j}\Big(\sum_{i=j}^n
(-1)^{n-i}\begin{bmatrix}n\\ i\end{bmatrix} \begin{Bmatrix}i\\
j\end{Bmatrix}\Big)
</span></p>
<p>那么可以发现<span class="math inline">\Big(\sum_{i=j}^n
(-1)^{n-i}\begin{bmatrix}n\\ i\end{bmatrix} \begin{Bmatrix}i\\
j\end{Bmatrix}\Big)=[n=j]</span>，类似的我们也有<span
class="math inline">\Big(\sum_{i=j}^n \begin{Bmatrix}n\\ i\end{Bmatrix}
(-1)^{i-j}\begin{bmatrix}i\\ j\end{bmatrix}\Big)=[n=j]</span>。</p>
<p>于是就可以用来反演了。假设有两个数组<span
class="math inline">f,g</span>满足：</p>
<p><span class="math display">
g_i=\sum_{j=0}^i\begin{Bmatrix}i\\j\end{Bmatrix}f_j
</span></p>
<p>那么我们就有：</p>
<p><span class="math display">
f_i=\sum_{j=0}^i(-1)^{i-j}\begin{bmatrix}i\\j\end{bmatrix}g_j
</span></p>
<p>原文：</p>
<blockquote>
<p>斯特林数分为第一类斯特林数和第二类斯特林数，其形式和二项式系数非常像，都是二元函数。下面逐一介绍。</p>
<p>第一类斯特林数，设两个变量为<span class="math inline">n</span>，<span
class="math inline">k</span>，那么其表示为：</p>
<p><span class="math display">
\begin{bmatrix} n \\ k \end{bmatrix}
</span></p>
<p>第一类斯特林数还有另一种表示方式，<span
class="math inline">s_n^k</span>（注意<span
class="math inline">s</span>是小写的）。</p>
<p>它的组合意义是，有<span
class="math inline">n</span>个不同的元素，将它们分成<span
class="math inline">k</span>个非空圆排列的方案数。这个定义看上去有点难理解，其实讲的通俗一点，就是你要将<span
class="math inline">n</span>个元素排成<span
class="math inline">k</span>个圈，一个圈如果可以通过旋转（但是不可以翻转）变成另一个圈，那么两个圈就是相同的。并且圈之间是没有顺序的。</p>
<p>下面来推导一下第一类斯特林数的递推式。我们假设前<span
class="math inline">n-1</span>个元素已经摆放好了，那么第<span
class="math inline">n</span>个元素要么自成一个新的圈，要么插入到前<span
class="math inline">n-1</span>个元素组成的圈中，一共有<span
class="math inline">n-1</span>个空位，所以得到：</p>
<p><span class="math display">
\begin{bmatrix} n \\ k \end{bmatrix}=\begin{bmatrix} n-1 \\ k-1
\end{bmatrix}+(n-1)* \begin{bmatrix} n-1 \\ k \end{bmatrix}
</span></p>
<p>注意判断边界条件，<span class="math inline">\begin{bmatrix} n \\ 0
\end{bmatrix}=[n=0]</span>，<span class="math inline">\begin{bmatrix} n
\\ n \end{bmatrix}=1</span>。</p>
<p>我们可以发现用递推式来求解第一类斯特林数是<span
class="math inline">O(nk)</span>的，有没有什么更快的方法？答案是肯定的，下面介绍的方法可以在<span
class="math inline">O(n\log n)</span>的时间内求出<span
class="math inline">k=0,1,2,...,n</span>的所有<span
class="math inline">\begin{bmatrix} n \\ k \end{bmatrix}</span>。</p>
<p>我们首先来研究一下第一类斯特林数的性质，我们知道<span
class="math inline">x</span>的<span
class="math inline">k</span>次上升幂为：</p>
<p><span class="math display">
x^{\overline k}=\prod_{i=0}^{k-1}x+i
</span></p>
<p>我们把<span
class="math inline">x</span>看作多项式中的未知数，将上式理解为多项式，然后我们考虑将其展开：</p>
<p><span class="math display">
x^{\overline k}=x^k+...???
</span></p>
<p>好像一下子推不出来了，这个任务还是比较困难的，那我们直接说出结论，尝试来证明它吧：</p>
<p><span class="math display">
x^{\overline k}=\sum_{i=0}^{k} \begin{bmatrix} k \\ i \end{bmatrix}
x^i
</span></p>
<p>在<span class="math inline">k=0</span>时，上式左右都为<span
class="math inline">1</span>，显然成立。现在来证明如果这个式子对于<span
class="math inline">k-1</span>成立，那么对<span
class="math inline">k</span>也成立，首先按照递推式分解第一类斯特林数：</p>
<p><span class="math display">
\sum_{i=0}^k \bigg( \begin{bmatrix} k-1 \\ i-1 \end{bmatrix} +
(n-1)* \begin{bmatrix} k-1 \\ i \end{bmatrix} \bigg) x^i
</span></p>
<p>拆开来，得到：</p>
<p><span class="math display">
\sum_{i=0}^k \begin{bmatrix} k-1 \\ i-1 \end{bmatrix} x^i
+(k-1)\sum_{i=0}^k \begin{bmatrix} k-1 \\ i \end{bmatrix} x^i
</span></p>
<p>去掉那些无意义的第一类斯特林数，再把第一个和式的<span
class="math inline">i</span>枚举范围从<span
class="math inline">1</span>到<span
class="math inline">k</span>改成<span
class="math inline">0</span>到<span
class="math inline">k-1</span>（差不多就是左移一位的意思），得到：</p>
<p><span class="math display">
x\sum_{i=0}^{k-1} \begin{bmatrix} k-1 \\ i \end{bmatrix} x^i +
(k-1)\sum_{i=0}^{k-1} \begin{bmatrix} k-1 \\ i \end{bmatrix} x^i
</span></p>
<p>于是我们就可以合并了，得到：</p>
<p><span class="math display">
(x+k-1)\sum_{i=0}^{k-1} \begin{bmatrix} k-1 \\ i \end{bmatrix} x^i
</span></p>
<p>因为性质已经对<span
class="math inline">k-1</span>成立，因此后面的和式就是<span
class="math inline">x^{\overline{k-1}}</span>，于是这个式子就等于<span
class="math inline">x^{\overline k}</span>，得证。</p>
<p>还有一点要说的是，如果把上升幂换成下降幂，很显然每一项只是又乘了<span
class="math inline">(-1)^{k-i}</span>。其实<span
class="math inline">(-1)^{k-i} \begin{bmatrix} k \\ i
\end{bmatrix}</span>叫做带符号的第一类斯特林数，也是很有用的，接下来也会提及关于它的应用（如果我不咕咕咕的话）。</p>
<p>直接利用这个性质，我们就可以用分治<span
class="math inline">FFT</span>做到<span class="math inline">O(n\log ^2
n)</span>，这已经很优秀了。不过利用下面的技巧可以做到<span
class="math inline">O(n \log n)</span>。</p>
<p>假设我们已经求出了<span class="math inline">x^{\overline
k}</span>的结果，我们可以进行如下操作在<span class="math inline">O(n\log
n)</span>时间内求出<span class="math inline">(x+k)^{\overline
k}</span>。</p>
<p>假设我们已经求得：</p>
<p><span class="math display">
x^{\overline k}=\sum_{i=0}^{k}a_i*x^i
</span></p>
<p>那么显然有：</p>
<p><span class="math display">
(x+k)^{\overline k}=\sum_{i=0}^k a_i*(x+k)^i
</span></p>
<p>对<span class="math inline">(x+k)^i</span>进行二项式展开：</p>
<p><span class="math display">
(x+k)^{\overline k}=\sum_{i=0}^k a_i* \Big( \sum_{j=0}^i {i \choose
j} x^j*k^{i-j} \Big)
</span></p>
<p>再交换一下前后的两个<span class="math inline">\sum</span>：</p>
<p><span class="math display">
(x+k)^{\overline k}=\sum_{j=0}^k x^j*\Big(\sum_{i=j}^k {i\choose
j}a_i*k^{i-j} \Big)
</span></p>
<p>已经可以发现一点<span
class="math inline">FFT</span>的影子了，我们再把二项式系数拆开并把<span
class="math inline">j!</span>提到前面：</p>
<p><span class="math display">
(x+k)^{\overline k}=\sum_{j=0}^k x^j *\frac{1}{j!}*\Big(\sum_{i=j}^k
(a_i*i!)*\frac{k^{i-j}}{(i-j)!}\Big)
</span></p>
<p>于是就可以<span class="math inline">FFT</span>了，接着我们计算<span
class="math inline">x^{\overline {2k}}=x^{\overline k}(x+k)^{\overline
k}</span>，就可以倍增求答案了，如果要计算<span
class="math inline">x^{\overline {2k+1}}</span>，只要再暴力乘以<span
class="math inline">x+2k</span>即可。于是递归式就是<span
class="math inline">T(n)=T(\frac{n}{2})+O(n\log
n)</span>，利用主定理计算得<span class="math inline">T(n)=O(n\log
n)</span>。</p>
<p>下面来讲一下第一类斯特林数的应用，有一个应用是可以利用带符号的第一类斯特林数在<span
class="math inline">O(k^2)</span>时间内求得<span
class="math inline">\sum_{i=0}^n
i^k</span>，即自然数幂次和（不过好像有更直观的做法…其实这是一个<span
class="math inline">k+1</span>次的多项式，所以计算<span
class="math inline">k+2</span>个不同的值再暴力插值插出多项式也可以。用高斯消元是<span
class="math inline">O(k^3)</span>的，而用拉格朗日插值是<span
class="math inline">O(k^2)</span>或者<span class="math inline">O(k\log
^2
k)</span>的，但第一类斯特林数的做法比较优美，并且是不需要求逆元的）。</p>
<p>我们先来证明一个小引理：</p>
<p><span class="math display">
\sum_{i=0}^n {i \choose k} = {n+1 \choose k+1}
</span></p>
<p>证明非常简单，还是用归纳法。当<span
class="math inline">n=0</span>时左右两边都为<span
class="math inline">[k=0]</span>，显然正确。现在来证明如果对于<span
class="math inline">n-1</span>成立，那么对于<span
class="math inline">n</span>也成立。把右边的二项式系数拆开得到：</p>
<p><span class="math display">
\sum_{i=0}^k {i \choose k} = {n \choose k} + {n \choose k+1}
</span></p>
<p>把等式两边的<span class="math inline">{n \choose
k}</span>都消掉，得到：</p>
<p><span class="math display">
\sum_{i=0}^{n-1} = {n \choose k+1}
</span></p>
<p>该式就是我们在<span
class="math inline">n-1</span>时已经证明的形式，因此引理得证。</p>
<p>现在我们来用第一类斯特林数求自然数幂次和。由第一类斯特林数的性质得到：</p>
<p><span class="math display">
{n \choose k}*k!=\frac{n!}{(n-k)!}=n^{\underline k}=\sum_{i=0}^k
(-1)^{k-i} \begin{bmatrix} k \\ i \end{bmatrix} n^i
</span></p>
<p>因此：</p>
<p><span class="math display">
n^k={n \choose k}*k!-\sum_{i=0}^{k-1} (-1)^{k-i} \begin{bmatrix} k
\\ i \end{bmatrix} n^i
</span></p>
<p>我们设<span class="math inline">S_{k,n}=\sum_{i=0}^n
i^k</span>，则：</p>
<p><span class="math display">
S_{k,n}=\sum_{i=0}^n \Bigg( {i \choose k}*k!-\sum_{j=0}^{k-1}
(-1)^{k-j} \begin{bmatrix} k \\ j \end{bmatrix} i^j \Bigg)
</span></p>
<p>把里面的两项拆开，得到：</p>
<p><span class="math display">
S_{k,n}=\sum_{i=0}^n {i \choose k}*k!-\sum_{i=0}^n
\sum_{j=0}^{k-1}(-1)^{k-j} \begin{bmatrix} k \\ j \end{bmatrix} i^j
</span></p>
<p>利用我们之前说的引理把第一项转化了并把后面一项的<span
class="math inline">i</span>合并，得到：</p>
<p><span class="math display">
S_{k,n}={n+1 \choose k+1} *k!-\sum_{j=0}^{k-1} (-1)^{k-j}
\begin{bmatrix} k \\ j \end{bmatrix} S_{j,n}
</span></p>
<p>再把第一项稍微进行一下转化，后面一项的<span
class="math inline">j</span>换成<span
class="math inline">i</span>，得到：</p>
<p><span class="math display">
S_{k,n}= \frac{\prod_{i=n-k+1}^n i}{k+1}-\sum_{i=0}^{k-1} (-1)^{k-i}
\begin{bmatrix} k \\ i \end{bmatrix} S_{i,n}
</span></p>
<p>注意到前面那项一定是可以整除的，所以不需要求逆元。接下来这要用这个式子<span
class="math inline">O(k^2)</span>递推就好了，这里的第一类斯特林数可以直接用递推式<span
class="math inline">O(k^2)</span>求。</p>
<p>呼，第一类斯特林数终于告一段落了。现在来讲清真很多的第二类斯特林数。</p>
<p>设两个变量是<span class="math inline">n</span>，<span
class="math inline">k</span>，那么其表示为：</p>
<p><span class="math display">
\begin{Bmatrix} n \\ k \end{Bmatrix}
</span></p>
<p>它的组合意义是，有<span
class="math inline">n</span>个不同的元素，将它们划分为<span
class="math inline">k</span>个非空集合的方案数。集合内和集合间都是无序的。</p>
<p>来考虑第二类斯特林数的递推，我们同样假设前<span
class="math inline">n-1</span>个元素已经放好了，那么第<span
class="math inline">n</span>个元素要么成为一个新的集合，要么加入到已有的集合中的一个，那么其递推式就是：</p>
<p><span class="math display">
\begin{Bmatrix} n \\ k \end{Bmatrix}=\begin{Bmatrix} n-1 \\ k-1
\end{Bmatrix}+k*\begin{Bmatrix} n-1 \\ k \end{Bmatrix}
</span></p>
<p>现在来考虑一下第二类斯特林数的通项公式（没错第二类斯特林数是有简单的通项公式的，和第一类斯特林数相比就是这么清真。）</p>
<p>考虑把<span class="math inline">n</span>个不同元素分成<span
class="math inline">k</span>个可空集合，并且集合间是有序的方案数，很显然是<span
class="math inline">k^n</span>。而这些方案是由划分为<span
class="math inline">i=0,1,2,...,k</span>个非空集合的方案组成的，注意此时我们要求集合间有序，而非空集合之间因为元素互不相同所以显然是两两不同的，因此方案数就是<span
class="math inline">\begin{Bmatrix} n \\ i
\end{Bmatrix}*i!</span>，那么我们就有：</p>
<p><span class="math display">
k^n=\sum_{i=0}^k {k \choose i} \begin{Bmatrix} n \\ i
\end{Bmatrix}*i!
</span></p>
<p>显然这又是一个二项式反演的形式（二项式反演真是好东西），于是我们就得到：</p>
<p><span class="math display">
\begin{Bmatrix} n \\ k \end{Bmatrix}*k!=\sum_{i=0}^k (-1)^{k-i} {k
\choose i} i^n
</span></p>
<p>因此：</p>
<p><span class="math display">
\begin{Bmatrix} n \\ k \end{Bmatrix} = \frac{\sum_{i=0}^k (-1)^{k-i}
{k \choose i} i^n}{k!}
</span></p>
<p>但是直接根据通项公式求是<span
class="math inline">O(k)</span>的，我们还是来考虑一下如何在<span
class="math inline">O(n\log n)</span>的时间内求出<span
class="math inline">k=0,1,2,...,n</span>的所有<span
class="math inline">\begin{Bmatrix} n \\ k \end{Bmatrix}</span>。</p>
<p>我们把通项公式中的二项式系数拆开，于是分母与分子的<span
class="math inline">k!</span>就消掉了，得到：</p>
<p><span class="math display">
\begin{Bmatrix} n \\ k \end{Bmatrix}=\sum_{i=0}^k
\frac{(-1)^{k-i}}{(k-i)!}*\frac{i^n}{i!}
</span></p>
<p>这是一个非常简单的<span
class="math inline">FFT</span>形式，直接做即可。复杂度<span
class="math inline">O(n\log n)</span>。</p>
<p>第二类斯特林数的一个性质就是我们在求通项公式的时候用到的那个，这个稍加推导也可以求自然数幂次和，并且如果支持求逆元操作，那么其复杂度是<span
class="math inline">O(k\log k)</span>的，否则其复杂度是<span
class="math inline">O(k^2)</span>的，这比第一类斯特林数更加实用。</p>
<p>我们已经知道（为了方便我把上面式子的<span
class="math inline">n</span>和<span
class="math inline">k</span>互换了）：</p>
<p><span class="math display">
n^k=\sum_{i=0}^n {n \choose i} \begin{Bmatrix} k \\ i \end{Bmatrix}
*i!
</span></p>
<p>注意到<span
class="math inline">i&gt;k</span>时第二类斯特林数的值一定为<span
class="math inline">0</span>，因此枚举范围改为<span
class="math inline">0</span>~<span class="math inline">k</span>：</p>
<p><span class="math display">
n^k=\sum_{i=0}^k {n \choose i} \begin{Bmatrix} k \\ i \end{Bmatrix}
*i!
</span></p>
<p>因此：</p>
<p><span class="math display">
S_{k,n}=\sum_{j=0}^n \sum_{i=0}^k {j \choose i} \begin{Bmatrix} k \\
i \end{Bmatrix} *i!
</span></p>
<p>同样，交换两个<span class="math inline">\sum</span>的顺序：</p>
<p><span class="math display">
S_{k,n}=\sum_{i=0}^k \begin{Bmatrix} k \\ i \end{Bmatrix}*i! \Bigg(
\sum_{j=i}^n {j \choose i} \Bigg)
</span></p>
<p>再次利用之前的引理，后面的和式就转化为：</p>
<p><span class="math display">
S_{k,n}=\sum_{i=0}^k \begin{Bmatrix} k \\ i \end{Bmatrix} * i! *
{n+1 \choose i+1}
</span></p>
<p>最终得到：</p>
<p><span class="math display">
S_{k,n}=\sum_{i=0}^k \begin{Bmatrix} k \\ i \end{Bmatrix}
\frac{\prod_{j=n-i+1}^{n+1} j}{i+1}
</span></p>
<p>显然那个连乘是可以递推的，然后就好了。<del>为什么感觉第二类斯特林数什么都比第一类斯特林数简洁。</del></p>
</blockquote>
</body>
</html>
