<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>有史以来打的最烂的一场…B题都WA了两发，D题数树不知道结论不会做，E题没调出来…GG了。</p>
<p>也说明我实力其实还不够吧…再多加练习，我还有机会继续努力。</p>
<p><a
href="https://codeforces.com/contest/1109/problems">题目链接</a></p>
<h3 id="a.-sasha-and-a-bit-of-relax">A. Sasha and a Bit of Relax</h3>
<p>题意：给定一个长度为<span class="math inline">n</span>的序列<span
class="math inline">a</span>，求有多少个长度为偶数的区间满足区间前一半数的异或和等于后一半数的异或和。<span
class="math inline">n\leq 3*10^5,a_i\leq 2^{20}</span>。</p>
<p>题解：考虑前一半数的异或和等于后一半数的异或和等价于整体异或和为<span
class="math inline">0</span>，那么只需要做异或前缀和，统计位置的奇偶性相同的前缀和中，值相同的对数即可。复杂度<span
class="math inline">O(n)</span>。</p>
<h3 id="b.-sasha-and-one-more-name">B. Sasha and One More Name</h3>
<p>题意：给定一个回文串<span
class="math inline">s</span>，你要将其分割<span
class="math inline">k</span>次（划分为<span
class="math inline">k+1</span>段）并重新排列，将其变成一个与原来不同的回文串。求<span
class="math inline">k</span>的最小值，无解则输出<span
class="math inline">-1</span>。<span class="math inline">|s|\leq
5000</span>。</p>
<p>题解：先考虑无解的情况，对于偶回文，全部相同则无解；对于奇回文，除中间的字符外全部相同则无解。考虑另外的所有情况，一定可以构造一种<span
class="math inline">k=2</span>的方法：我们设<span
class="math inline">s^R</span>代表字符串<span
class="math inline">s</span>反转之后的结果，那么回文串的结构为<span
class="math inline">a(b)a^R</span>，由于<span
class="math inline">a</span>并非全部字符相同，因此一定存在至少一个非回文前缀，那么在两端截取这一前（后）缀并交换即可得到不同的回文串。于是我们直接枚举所有<span
class="math inline">k=1</span>的方案，判断是否可行即可。复杂度<span
class="math inline">O(|s|^2)</span>。</p>
<h3 id="c.-sasha-and-a-patient-friend">C. Sasha and a Patient
Friend</h3>
<p>题意：有一个容量无穷大的容器可以装“耐心”，容器会以某个速率加入或抽取耐心，如果某个时刻耐心为<span
class="math inline">0</span>，那么容器损坏。有三种操作：<span
class="math inline">1</span>、在时刻<span
class="math inline">t</span>将容器的速率改为<span
class="math inline">s</span>。<span
class="math inline">2</span>、取消在时刻<span
class="math inline">t</span>对速率的修改。<span
class="math inline">3</span>、询问假如容器时刻<span
class="math inline">l</span>有<span
class="math inline">v</span>的耐心，那么在时刻<span
class="math inline">r</span>之前容器是否会损坏，如果会那么时刻是多少，用<span
class="math inline">double</span>输出。</p>
<p>题解：考虑全局维护一棵平衡树（无旋<span
class="math inline">\text{Treap}</span>），一个点代表一个事件，同时维护子树代表的这段时间的信息。每个点要维护这些东西：子树内事件的最早，最晚时刻，时刻最晚的事件的速率，和执行前相比，执行完子树的事件后耐心的变化量，会使容器在执行子树事件时损坏的最大初始容量。更新的过程可以通过推导求出。至于询问，只需要分裂出对应的事件，在这棵子树上二分即可。复杂度<span
class="math inline">O(n\log n)</span>。</p>
<h3 id="d.-sasha-and-interesting-fact-from-graph-theory">D. Sasha and
Interesting Fact from Graph Theory</h3>
<p>题意：求<span class="math inline">n</span>个点，边权为<span
class="math inline">1\sim m</span>的整数的所有树中，点对<span
class="math inline">a,b</span>的距离为<span
class="math inline">m</span>的种数是多少，模<span
class="math inline">10^9+7</span>。<span class="math inline">n,m\leq
10^6</span>。</p>
<p>首先有一个结论：你要给<span
class="math inline">n</span>个点做生成树，但其中一些点之间已经有边，这些边组成了<span
class="math inline">k</span>个连通块，某个连通块的大小为<span
class="math inline">a_i</span>，那么生成树的个数为<span
class="math inline">n^{k-2}\prod_i
a_i</span>，可以手玩矩阵树行列式来证明（或者看<a
href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/loj2983-wc2019-shuo-shu">这里</a>）。</p>
<p>有了这个结论这道题就很简单了：枚举<span
class="math inline">a,b</span>之间的边数<span
class="math inline">i</span>，那么先有顺序的选出<span
class="math inline">i-1</span>个点作为中间节点，方案数为<span
class="math inline">{n-2 \choose
i-1}*(i-1)!</span>，在生成树中这总共<span
class="math inline">i+1</span>个点已经形成了一个连通块，因此在这基础上的方案数就是<span
class="math inline">n^{n-i-2}*(i+1)</span>，再考虑边权，<span
class="math inline">a,b</span>之间的<span
class="math inline">i</span>条边边权和为<span
class="math inline">m</span>，用插板法可知方案数为<span
class="math inline">{m-1\choose i-1}</span>，其余边随意，方案数<span
class="math inline">m^{n-1-i}</span>，因此总方案数为：</p>
<p><span class="math display">
\sum_{i=1}^{\min(m,n-1)}{n-2\choose
i-1}*(i-1)!*n^{n-i-2}*(i+1)*{m-1\choose i-1}*m^{n-1-i}
</span></p>
<p>直接计算即可。</p>
<h3 id="e.-sasha-and-a-very-easy-test">E. Sasha and a Very Easy
Test</h3>
<p>题意：维护一个长度为<span class="math inline">n</span>的数组<span
class="math inline">a</span>，支持区间乘，单点除（保证可以整除），区间求和在模<span
class="math inline">mod</span>意义下的结果。不保证<span
class="math inline">mod</span>为质数。<span class="math inline">n\leq
10^5</span>。</p>
<p>题解：直接做比较麻烦，考虑将<span
class="math inline">mod</span>质因数分解，每次做在模<span
class="math inline">p^k</span>意义下的结果最后CRT合并。那么每个数可以分解成<span
class="math inline">a*p^b</span>，其中<span
class="math inline">a</span>和<span
class="math inline">p</span>互质。那么对每个数只需要记录<span
class="math inline">a</span>，<span class="math inline">b</span>，<span
class="math inline">a*p^b</span>以及对应的区间和来建立线段树，就可以完成题目的任务。复杂度<span
class="math inline">O(n\log^2 n)</span>。</p>
<h3 id="f.-sasha-and-algorithm-of-silences-sounds">F. Sasha and
Algorithm of Silence’s Sounds</h3>
<p>题意：给定一个<span
class="math inline">n*m</span>的矩阵，每个数在<span
class="math inline">1\sim n*m</span>之间并且两两不同。求有多少对<span
class="math inline">l,r</span>满足数字<span class="math inline">l\sim
r</span>在矩阵上的位置是一棵树（四连通）。<span
class="math inline">n,m\leq 1000,n*m\leq 2*10^5</span>。</p>
<p>题解：判断是否是树有一个简单的方法：首先判断是否是森林，再判断<span
class="math inline">点数-边数</span>是否为<span
class="math inline">1</span>即可。第一步，可以发现对于每个右端点，只有一个后缀的左端点满足是森林，并且最左端的位置随最右端的右移而右移。那么这一部分可以使用<span
class="math inline">\text{two pointers}</span>的思想，用<span
class="math inline">\text{LCT}</span>来维护对于每一个右端点最左端的满足是森林的点。至于<span
class="math inline">边数-点数</span>的限制，考虑维护一棵线段树，由于平面图的点度只有<span
class="math inline">4</span>因此可以暴力扫描。于是就是区间加以及对满足是森林的一段区间求<span
class="math inline">1</span>的个数。可以发现在是森林的情况下，<span
class="math inline">点数-边数</span>最少为<span
class="math inline">1</span>，那么线段树只需要记录区间最小值的个数即可。复杂度<span
class="math inline">O(nm(\log nm))</span>。</p>
</body>
</html>
