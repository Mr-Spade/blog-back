<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span class="math inline">0</span>、写在前面</p>
<p>为了方便本文的描述，定义如下内容：</p>
<p>我们说<span class="math inline">f</span>是一个次数界为<span
class="math inline">n</span>（下文不严谨地简称为<span
class="math inline">n</span>次）的多项式，是指<span
class="math inline">f</span>是一个下标集合为<span
class="math inline">0,1,2,...,n-1</span>的数组，并代表：</p>
<p><span class="math display">
\sum_{i=0}^{n-1}f_i x^i
</span></p>
<p>这个多项式。</p>
<p>我们用<span class="math inline">f(x_0)</span>代表多项式<span
class="math inline">f</span>在<span
class="math inline">x_0</span>处的值。</p>
<p><span class="math inline">1</span>、多项式乘法</p>
<p>利用<span class="math inline">\rm
FFT</span>就可以将多项式乘法的复杂度优化到<span
class="math inline">O(n\log
n)</span>。由于其讲解较为繁琐并且已逐渐普及<del>（想必读者也不是来学这个的）</del>，因此略过<span
class="math inline">\rm FFT</span>以及同样普及的<span
class="math inline">\rm NTT</span>。</p>
<p>至于<span class="math inline">\rm MTT</span>，我们可以将系数拆成<span
class="math inline">32768\cdot
a+b</span>的形式缩小值域，将一个多项式拆为两个。做四次卷积以后，将得到的答案合并并取模即可。</p>
<p>当然<span class="math inline">\rm MTT</span>还有利用<span
class="math inline">\rm
FFT</span>模数计算再用中国剩余定理合并的做法，但第一种做法更加直观。</p>
<p><span class="math inline">2</span>、分治<span class="math inline">\rm
FFT</span></p>
<p>有两种分治<span class="math inline">\rm
FFT</span>，先来讲比较简单的第一种。</p>
<p>如果我们有一个长度为<span class="math inline">n</span>的数组<span
class="math inline">a</span>，并且希望求：</p>
<p><span class="math display">
\prod_{i=0}^{n-1}(x+a_i)
</span></p>
<p>直接按照暴力计算，是<span
class="math inline">O(n^2)</span>的（因为每一个只有两项，所以一次暴力乘法只有<span
class="math inline">O(n)</span>）。如果我们把乘法用<span
class="math inline">\rm FFT</span>来实现，我们就得到了<span
class="math inline">O(n^2\log n)</span>的<del>优秀</del>复杂度。</p>
<p>怎么做才会更快呢？</p>
<p>分治往往能带来更加优秀的复杂度。直接利用<span class="math inline">\rm
FFT</span>之所以慢，是因为相乘的两个多项式次数相差太大，这会非常浪费。</p>
<p>那我们不妨考虑先计算左半部分和右半部分的积。这是两个<span
class="math inline">O(n)</span>次的多项式，直接用<span
class="math inline">\rm FFT</span>在<span class="math inline">O(n\log
n)</span>的时间内相乘即可。那么我们的递归式就是：</p>
<p><span class="math display">
T(n)=2T(n/2)+O(n\log n)
</span></p>
<p>解得<span class="math inline">T(n)=O(n\log
^2n)</span>，复杂度得到了很大优化。</p>
<p>那么再来讲讲<span class="math inline">dark</span>的第二种分治<span
class="math inline">\rm FFT</span>。</p>
<p>你有一个下标集合为<span
class="math inline">\{1,2,...,n\}</span>的数组<span
class="math inline">f</span>，你想要求一个下标集合为<span
class="math inline">\{0,1,2,...,n\}</span>的数组<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g_i=\sum_{j=1}^{i}f_jg_{i-j}
</span></p>
<p>边界条件<span class="math inline">g_0=1</span>。</p>
<p>看上去直接求好像有点困难，那么我们来考虑分治。我们把数组<span
class="math inline">g</span>拆为前后两半，显然后一半对前一半是没有影响的，直接递归求解前一半。求解完毕以后我们来计算前一半对后一半的贡献，这时我们直接根据上面的式子<span
class="math inline">\rm
FFT</span>即可，因为此时前后的影响已经被我们用分治消除了。最后我们递归继续后一半的求解。</p>
<p>综上所述，递归式为：</p>
<p><span class="math display">
T(n)=2T(n/2)+O(n\log n)
</span></p>
<p>解得<span class="math inline">T(n)=O(n\log^2
n)</span>，复杂度较优秀。</p>
<p><span
class="math inline">P.S.</span>第二个问题其实有复杂度更优秀的解法，可以参见下面的“多项式求逆”。但是分治的思想更加直观，并且有的类型并不能利用“多项式求逆”来做，因此分治<span
class="math inline">\rm FFT</span>的作用还是很大的。</p>
<p><span class="math inline">3</span>、多项式倍增（思想）</p>
<p>倍增是接下来对许多多项式问题求解的重要方法。</p>
<p>在多项式中可能有一些我们要求的多项式次数是无限的，那么一般我们只需要知道它的前<span
class="math inline">n</span>项，即<span class="math inline">\bmod
x^n</span>的结果即可。直接求解或许也比较困难，此时可以考虑倍增。</p>
<p>我们先用简单的方法求出<span class="math inline">\bmod
x</span>的平凡情况，然后就只需要考虑如何从<span
class="math inline">\bmod x^k</span> 的结果<span
class="math inline">\widehat f</span>推到<span class="math inline">\bmod
x^{2k}</span>的结果<span
class="math inline">f</span>即可。一般来说，利用<span
class="math inline">(f-\widehat f)^2\equiv 0 (\bmod
x^{2k})</span>这个性质就可以得到很方便的求解方法。</p>
<p><span class="math inline">4</span>、多项式求逆</p>
<p>多项式求逆是这样一个问题，已知一个<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，我们希望求一个<span
class="math inline">n</span>次多项式<span
class="math inline">g=f^{-1}</span>，即：</p>
<p><span class="math display">
f*g\equiv 1(\bmod x^n)
</span></p>
<p>显然要求<span class="math inline">f</span>的常数项不为<span
class="math inline">0</span>。那么在<span class="math inline">\bmod
x</span>意义下，直接求得<span
class="math inline">g_0=f_0^{-1}</span>。</p>
<p>现在我们考虑从<span class="math inline">\bmod x^k</span>的结果<span
class="math inline">\widehat g</span>推出<span class="math inline">\bmod
x^{2k}</span>的结果<span class="math inline">g</span>。我们有：</p>
<p><span class="math display">
(g-\widehat g)^2\equiv 0(\bmod x^{2k})
</span></p>
<p>把平方展开，得到：</p>
<p><span class="math display">
g^2-2g\widehat g+\widehat g^2\equiv 0(\bmod x^{2k})
</span></p>
<p>这个式子好像有点<span
class="math inline">dark</span>，但是我们已经知道<span
class="math inline">f*g\equiv 1(\bmod
x^{2k})</span>，因此我们对等式两边同时乘以<span
class="math inline">f</span>，得到：</p>
<p><span class="math display">
g-2\widehat g+f\widehat g^2\equiv 0(\bmod x^{2k})
</span></p>
<p>移项，得：</p>
<p><span class="math display">
g\equiv 2\widehat g-f\widehat g^2(\bmod x^{2k})
</span></p>
<p>就可以直接进行倍增。递归式为<span
class="math inline">T(n)=T(n/2)+O(n\log n)</span>，解得<span
class="math inline">T(n)=O(n\log n)</span>。</p>
<p>多项式求逆也是很多多项式问题的基础，在接下来的几种多项式黑科技中起到了很大的作用。</p>
<p>那么再来举一个应用多项式求逆的例子，就是在之前的“分治<span
class="math inline">\rm
FFT</span>”里提到的第二个问题。为了保持完整我们再陈述一遍：</p>
<p>你有一个下标集合为<span
class="math inline">\{1,2,...,n\}</span>的数组<span
class="math inline">f</span>，你想要求一个下标集合为<span
class="math inline">\{0,1,2,...,n\}</span>的数组<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g_i=\sum_{j=1}^{i}f_jg_{i-j}
</span></p>
<p>边界条件<span class="math inline">g_0=1</span>。</p>
<p>我们先想办法把上面的式子化成普通的卷积形式。我们把<span
class="math inline">j</span>的枚举范围从<span
class="math inline">1,2,...,i</span>改为卷积形式的<span
class="math inline">0,1,2,...,i</span>，此时我们发现多计算了<span
class="math inline">f_0g_i</span>这一项。那么我们不妨令<span
class="math inline">f_0=0</span>，我们就消去了这一项的贡献。同时注意到作为边界的<span
class="math inline">g_0</span>如果直接用这个卷积形式计算会得到<span
class="math inline">0</span>，那么我们可以强制将结果加<span
class="math inline">1</span>。经过这番操作卷积的答案就为<span
class="math inline">g</span>了。于是我们得到了非常优美的式子：</p>
<p><span class="math display">
g=fg+1
</span></p>
<p>我们移项，得到：</p>
<p><span class="math display">
(1-f)g=1
</span></p>
<p>利用多项式求逆求出<span class="math inline">(1-f)^{-1}(\bmod
x^{n+1})</span>，在两边同时乘上，于是得到了：</p>
<p><span class="math display">
g\equiv \frac{1}{1-f}(\bmod x^{n+1})
</span></p>
<p>由于我们只要知道<span class="math inline">g</span>的前<span
class="math inline">n+1</span>项，因此<span class="math inline">\bmod
x^{n+1}</span>是没有关系的，于是我们就利用多项式求逆在<span
class="math inline">O(n\log n)</span>的时间内解决了这个问题。</p>
<p><span class="math inline">5</span>、多项式除法、取模</p>
<p>给你一个<span class="math inline">n</span>次多项式<span
class="math inline">f</span>，以及一个<span
class="math inline">m</span>次多项式<span
class="math inline">g</span>（<span
class="math inline">n&gt;m</span>），我们希望求一个<span
class="math inline">n-m+1</span>次多项式<span
class="math inline">q</span>以及一个<span
class="math inline">m-1</span>次多项式<span
class="math inline">r</span>，满足：</p>
<p><span class="math display">
f=qg+r
</span></p>
<p>那么我们称<span class="math inline">q</span>为<span
class="math inline">f</span>除以<span
class="math inline">g</span>的商，而称<span
class="math inline">r</span>为<span
class="math inline">f</span>除以<span
class="math inline">g</span>的余数。</p>
<p>现在我们来考虑如何求<span class="math inline">q</span>和<span
class="math inline">r</span>。我们先定义<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>的一种变换<span
class="math inline">f^R</span>：</p>
<p><span class="math display">
f^R=f(\frac{1}{x})*x^{n-1}
</span></p>
<p>不难看出<span class="math inline">f^R</span>即是将<span
class="math inline">f</span>的系数反转一下。因此我们可以在<span
class="math inline">O(n)</span>的时间内完成这个变换。</p>
<p>那么我们来推式子，我们不妨用<span
class="math inline">\frac{1}{x}</span>替换多项式内的<span
class="math inline">x</span>，这样的结果显然依旧正确：</p>
<p><span class="math display">
f(\frac{1}{x})=q(\frac{1}{x})g(\frac{1}{x})+r(\frac{1}{x})
</span></p>
<p>接着考虑在两边同乘<span
class="math inline">x^{n-1}</span>，得到：</p>
<p><span class="math display">
f(\frac{1}{x})*x^{n-1}=q(\frac{1}{x})*x^{m-1}*g(\frac{1}{x})*x^{n-m}+r(\frac{1}{x})*x^{m-2}*x^{n-m+1}
</span></p>
<p>不难发现我们已经有意为那个变换做好了准备，那么我们将四个多项式都用变换来代替：</p>
<p><span class="math display">
f^R=q^Rg^R+r^R*x^{n-m+1}
</span></p>
<p>我们考虑消去最后一项，那么不妨把式子放到<span
class="math inline">\bmod
x^{n-m+1}</span>的意义下。此时最后一项肯定为<span
class="math inline">0</span>，于是就消失了：</p>
<p><span class="math display">
f^R\equiv q^Rg^R(\bmod x^{n-m+1})
</span></p>
<p>我们发现既然<span class="math inline">q</span>是<span
class="math inline">n-m+1</span>次的，那么<span
class="math inline">q^R</span>也是<span
class="math inline">n-m+1</span>次的，<span class="math inline">\bmod
x^{n-m+1}</span>对其没有影响。于是我们求<span
class="math inline">g^R</span>的逆，就得到：</p>
<p><span class="math display">
q^R\equiv \frac{f^R}{g^R}(\bmod x^{n-m+1})
</span></p>
<p>于是我们就求得了<span
class="math inline">q^R</span>，然后简单地再做一次变换就得到了<span
class="math inline">q</span>。此时算<span
class="math inline">r</span>就很方便了，直接计算<span
class="math inline">f-qg</span>即可。</p>
<p>下面来讲一个多项式取模的应用——常系数齐次线性递推。</p>
<p>常系数齐次线性递推是指这样一个问题，给你一个数<span
class="math inline">k</span>，接着对于<span
class="math inline">i=1,2,...,k</span>，给出<span
class="math inline">a_i</span>，代表递推的系数。再对于<span
class="math inline">i=0,1,2,...,k-1</span>，给出<span
class="math inline">f_i</span>作为初始值，对于<span
class="math inline">i\geq k</span>，数列<span
class="math inline">f</span>满足：</p>
<p><span class="math display">
f_i=\sum_{j=1}^k a_j*f_{i-j}
</span></p>
<p>最后给你一个数<span class="math inline">n</span>，需要求出<span
class="math inline">f_n</span>。<span
class="math inline">n</span>的范围很大。</p>
<p>显然直接递推是不可行的，我们不妨把思路放的巧妙一些。我们设有一个奇怪的<span
class="math inline">x</span>，其满足<span
class="math inline">x^i=f_i</span>（有点难理解，你不妨假设<span
class="math inline">x</span>只是一个代号，它根本不是一个数），那么它一定满足：</p>
<p><span class="math display">
x^k=\sum_{i=1}^k a_j*x^{k-i}
</span></p>
<p>于是我们移项，得到：</p>
<p><span class="math display">
x^k-\sum_{i=1}^k a_i*x^{k-i}=0
</span></p>
<p>我们将其当作一个<span
class="math inline">k+1</span>次的多项式来看待，那么如果我们将<span
class="math inline">x^n</span>对这个多项式取模，得到了商和余数。因为模多项式为<span
class="math inline">0</span>，因此商乘以这个模多项式的答案没有贡献，我们只关心这个余数。显然余数是一个<span
class="math inline">k</span>次多项式，你只需要知道<span
class="math inline">x^0,x^1,...,x^{k-1}</span>即可得到答案。而数列<span
class="math inline">f</span>的前<span
class="math inline">k</span>项是给出的，因此代入计算就可以了。因此整个过程只需要一个意义为卷积的乘法，以及意义为多项式取模的取模的快速幂就可以在<span
class="math inline">O(k\log k\log n)</span>的时间内完成这个操作。</p>
<p><span class="math inline">\rm upd</span>：更详细的证明可以看<a
href="https://www.cnblogs.com/Mr-Spade/p/9832418.html">这里</a>。</p>
<p><span class="math inline">6</span>、多项式求导、积分</p>
<p>这是两个很简单的变换，是为了下面的内容做好准备。</p>
<p>设<span class="math inline">f</span>是一个<span
class="math inline">n</span>次多项式，那么<span
class="math inline">f</span>的导数<span
class="math inline">f&#39;</span>就是一个<span
class="math inline">n-1</span>次多项式，并且满足：</p>
<p><span class="math display">
f&#39;_i=(i+1)f_{i+1}
</span></p>
<p>直接<span class="math inline">O(n)</span>计算即可。</p>
<p>设<span class="math inline">f</span>是一个<span
class="math inline">n</span>次多项式，那么<span
class="math inline">f</span>的积分<span class="math inline">\int
f</span>就是一个<span
class="math inline">n+1</span>次多项式，并且满足：</p>
<p><span class="math display">
\int f_i=\frac{f_{i-1}}{i}
</span></p>
<p>边界条件<span class="math inline">\int f_0=0</span>。</p>
<p>同样<span class="math inline">O(n)</span>计算即可。</p>
<p><span class="math inline">7</span>、多项式<span
class="math inline">\ln</span></p>
<p><del>事情开始变得诡异起来了。</del></p>
<p>多项式求<span
class="math inline">\ln</span>是这样一个问题，给你一个<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，满足<span
class="math inline">f_0=1</span>，你需要求一个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g\equiv \ln f(\bmod x^n)
</span></p>
<p>看到这个是不是一下子有点懵啊…没关系，我们来冷静分析。函数<span
class="math inline">\ln(x)</span>的一个特点就是<span
class="math inline">\ln&#39;(x)=\frac{1}{x}</span>，这就一下子好办了，我们把这个结论照搬到多项式上面去，利用复合函数的求导法则，对上面的等式两边求导，得到：</p>
<p><span class="math display">
g&#39;\equiv \frac{f&#39;}{f}(\bmod x^n)
</span></p>
<p>这是不是非常简单啊，直接多项式求逆就得到了<span
class="math inline">g&#39;</span>，那么我们再将等式两边积分，就得到：</p>
<p><span class="math display">
g\equiv \int \frac{f&#39;}{f}(\bmod x^n)
</span></p>
<p>不过还有一个小疑问，求导一次再积分一次不是会丢掉常数项吗，这怎么办呢。其实没关系，我们已经保证<span
class="math inline">f_0=1</span>，而<span class="math inline">\ln
1=0</span>，因此<span class="math inline">g</span>的常数项就是<span
class="math inline">0</span>。于是我们就做完了。</p>
<p><span
class="math inline">8</span>、多项式牛顿迭代、泰勒展开（思想）</p>
<p>接下来我们讲一下多项式牛顿迭代和泰勒展开，为接下来的工作做准备。话说多项式真是强啊什么都能套上去。</p>
<p>先来讲牛顿迭代。</p>
<p>我们知道，如果我们希望在实数域内求得某个处处可导函数<span
class="math inline">f(x)</span>的零点的近似值，我们就可以用牛顿迭代来解决。我们随意选择一个初值，设其为<span
class="math inline">x_0</span>，然后开始迭代。每一次从<span
class="math inline">x_i</span>迭代到<span
class="math inline">x_{i+1}</span>，我们的精度会得到很大提升，迭代式子为：</p>
<p><span class="math display">
x_{i+1}=x_i-\frac{f(x_i)}{f&#39;(x_i)}
</span></p>
<p>其实就相当于<span class="math inline">x_{i+1}</span>是<span
class="math inline">f(x)</span>在<span
class="math inline">x_i</span>处的这条切线和横轴的交点，可以自己推一下式子证明。</p>
<p>我们将牛顿迭代应用到多项式上，具体来说：</p>
<p>我们给出一个<span class="math inline">n</span>次多项式<span
class="math inline">f</span>以及一个以多项式为参数，并且结果也是一个多项式的函数<span
class="math inline">G</span>，并希望计算出一个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
G(g)\equiv f(\bmod x^n)
</span></p>
<p>把问题简单转化一下，就是希望求得<span
class="math inline">G-f</span>的零点了。那么我们依然先求出<span
class="math inline">\bmod
x</span>意义下的简单结果，接着套用牛顿迭代的公式。设上一次迭代的答案为<span
class="math inline">\widehat g</span>，我们就得到：</p>
<p><span class="math display">
g=\widehat g-\frac{G(\widehat g)-f}{G&#39;(\widehat g)}
</span></p>
<p>为什么求导的时候多项式<span
class="math inline">f</span>会消失呢？这是因为<span
class="math inline">G</span>是关于多项式的函数，其导数反映的是当多项式变化时的变化幅度，因此不变的多项式<span
class="math inline">f</span>就被看作是常数项了。</p>
<p>同时我们可能还有一个疑问：牛顿迭代不是用来提高精度的吗？怎么在多项式上应用呢？我们感性理解一下，假设<span
class="math inline">\widehat g</span>是<span class="math inline">\bmod
x^k</span>意义下的结果，那么迭代式子显然可以得到一个<span
class="math inline">2k</span>次多项式，此时我们给出结论：通过这个牛顿迭代的式子，我们可以得到<span
class="math inline">\bmod
x^{2k}</span>意义下的结果。对它的证明将放到泰勒展开的讲解内。</p>
<p>于是我们就可以发现，利用牛顿迭代公式，我们可以做到类似倍增的效果。那么许多看似复杂的问题就可以解决了。</p>
<p>现在来讲一下多项式的泰勒展开。</p>
<p>我们刚刚已经得到了牛顿迭代在多项式上的应用，但是对于它的正确性，我们却是一知半解。幸好我们还有一种可以较简单的进行证明的方法：多项式泰勒展开。同时利用泰勒展开我们还可以获得一些问题求解的思路。</p>
<p>我们已经知道泰勒展开式为：</p>
<p><span class="math display">
f(x)=\sum_{i=0}^{\infty}\frac{f^{(i)}(x_0)}{i!}*(x-x_0)^i
</span></p>
<p>我们可以证明其对以多项式为参数的函数也成立，这和一般情况是一样的。那么我们依然考虑之前牛顿迭代所讲的问题，我们以<span
class="math inline">\bmod x^k</span>意义下的答案<span
class="math inline">\widehat g</span>代入<span
class="math inline">x_0</span>，求<span class="math inline">\bmod
x^{2k}</span>意义下的答案<span
class="math inline">g</span>，那么我们有：</p>
<p><span class="math display">
G(g)-f\equiv G(\widehat g)-f+G&#39;(\widehat g)*(g-\widehat g)+...(\bmod
x^{2k})
</span></p>
<p>我们再次利用这个性质：<span class="math inline">(g-\widehat
g)^2\equiv 0(\bmod
x^{2k})</span>，那么泰勒展开式中除了前两项以外都变成了<span
class="math inline">0</span>，于是便不用再考虑后面了，得到：</p>
<p><span class="math display">
G(g)-f\equiv G(\widehat g)-f+G&#39;(\widehat g)*(g-\widehat g)(\bmod
x^{2k})
</span></p>
<p>而我们又有<span class="math inline">G(g)-f\equiv 0(\bmod
x^{2k})</span>，于是左边就为<span
class="math inline">0</span>，我们移项得：</p>
<p><span class="math display">
-G&#39;(\widehat g)*(g-\widehat g)\equiv G(\widehat g)-f(\bmod x^{2k})
</span></p>
<p>两边同除<span class="math inline">-G&#39;(\widehat g)</span>：</p>
<p><span class="math display">
g-\widehat g\equiv -\frac{G(\widehat g)-f}{G&#39;(\widehat g)}(\bmod
x^{2k})
</span></p>
<p>再将<span class="math inline">\widehat g</span>加到右边：</p>
<p><span class="math display">
g\equiv \widehat g-\frac{G(\widehat g)-f}{G&#39;(\widehat g)}(\bmod
x^{2k})
</span></p>
<p>我们此时发现这就是牛顿迭代的公式，于是就完成了对牛顿迭代正确性的证明。当然泰勒展开的作用不只是证明牛顿迭代，我们在做题时可能推出一个关于某个多项式的奇怪式子，如果你能发现它正好是一个常见函数的泰勒展开，就可以用专门求这个函数的方法来解决——例如我们即将要讲的<span
class="math inline">\exp</span>。</p>
<p><span class="math inline">9</span>、多项式<span
class="math inline">\exp</span></p>
<p>多项式求<span
class="math inline">\exp</span>是这样一个问题，给你一个<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，满足<span
class="math inline">f_0=0</span>，你需要求一个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g=e^f(\bmod x^n)
</span></p>
<p>由于我们已经有了关于<span
class="math inline">\ln</span>的经验，看到这个就不要害怕了（都是纸老虎）。</p>
<p>但是直接利用<span
class="math inline">\ln</span>求导积分的那一套似乎不可行，因为<span
class="math inline">\exp</span>的导数依然是<span
class="math inline">\exp</span>。但是我们正好可以利用求<span
class="math inline">\ln</span>是简单的这一点，结合刚刚所讲的牛顿迭代来解决这个问题。</p>
<p>我们可以很快把<span
class="math inline">\exp</span>转化为这样的问题：求一个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
\ln g\equiv f(\bmod x^n)
</span></p>
<p>那么问题转化为求<span class="math inline">\ln
g-f</span>的零点，我们套用牛顿迭代的公式来倍增。因为<span
class="math inline">f</span>的常数项一定是<span
class="math inline">0</span>，因此<span
class="math inline">g</span>的常数项就是<span
class="math inline">1</span>，那么对于已知的<span
class="math inline">\bmod x^k</span>意义下的答案<span
class="math inline">\widehat g</span>，我们求<span
class="math inline">\bmod x^{2k}</span>意义下的答案<span
class="math inline">g</span>：</p>
<p><span class="math display">
g=\widehat g-\frac{\ln \widehat g-f}{\ln&#39;\widehat g}
</span></p>
<p>而我们知道<span class="math inline">\ln&#39; \widehat g=\widehat
g^{-1}</span>，因此：</p>
<p><span class="math display">
g=\widehat g(1-\ln\widehat g+f)
</span></p>
<p>就可以倍增求得答案了。递归式为<span
class="math inline">T(n)=T(n/2)+O(n\log n)</span>，解得<span
class="math inline">T(n)=O(n\log n)</span>。</p>
<p>将<span class="math inline">\exp</span>与<span
class="math inline">\ln</span>结合起来还可以得到多项式快速幂的<span
class="math inline">O(n\log n)</span>算法，具体来说：</p>
<p>给出一个<span class="math inline">n</span>次多项式<span
class="math inline">f</span>，以及次数<span
class="math inline">k</span>，我们希望求：</p>
<p><span class="math display">
f^k(\bmod x^n)
</span></p>
<p>直接利用快速幂来计算，每次乘法是<span class="math inline">O(n\log
n)</span>的，一共<span class="math inline">O(\log
k)</span>次乘法，总复杂度为<span class="math inline">O(n\log n\log
k)</span>，因为<span class="math inline">\bmod
x^n</span>，所以可以选择在每次乘法以后只保留前<span
class="math inline">n</span>项。这是一个优秀的算法，但是下面的做法可以比这更优秀：</p>
<p>假设多项式<span class="math inline">f</span>的系数不为<span
class="math inline">0</span>的最低次是<span
class="math inline">p</span>，那么我们可以先计算<span
class="math inline">(\frac{f}{a_p*x^p})^k</span>，最后再简单地乘以<span
class="math inline">a_p^k*x^{pk}</span>即可，经过这样的处理，我们就保证了常数项为<span
class="math inline">1</span>，<span class="math inline">\ln
f</span>就是可以计算的。</p>
<p>那么套用数域上的结论：<span class="math inline">x^k=e^{(\ln
x)*k}</span>，我们得到：</p>
<p><span class="math display">
f^k=e^{(\ln f)*k}
</span></p>
<p>于是我们只要先求<span class="math inline">\ln
f</span>，再把每一项乘以<span
class="math inline">k</span>，最后进行一次<span
class="math inline">\exp</span>即可。如果之前有过处理，就像之前说的一样处理回去。这样的复杂度就是<span
class="math inline">O(n\log n)</span>的。</p>
<p><span class="math inline">10</span>、多项式开方</p>
<p>多项式开方是这样一个问题，给你一个<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，满足数域内存在某个数<span
class="math inline">t</span>，使得<span
class="math inline">t^2=f_0</span>，你需要求一个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g\equiv \sqrt f(\bmod x^n)
</span></p>
<p>头回生二回熟，我们立刻可以发现这也可以利用牛顿迭代来解决对吧。我们现在是要求<span
class="math inline">g^2-f</span>的零点，那么<span
class="math inline">\bmod x</span>时的答案就是<span
class="math inline">f_0</span>的平方根（我们已保证了这一点可以做到），考虑用牛顿迭代公式进行倍增：</p>
<p><span class="math display">
g\equiv \widehat g-\frac{\widehat g^2-f}{(\widehat g^2)&#39;}(\bmod
x^{2k})
</span></p>
<p>显然<span class="math inline">(\widehat g^2)&#39;=2\widehat
g</span>，那么把式子转化成好求的形式：</p>
<p><span class="math display">
g\equiv \frac{1}{2}(\widehat g+\frac{f}{\widehat g})(\bmod x^{2k})
</span></p>
<p>这样做的复杂度也是<span class="math inline">O(n\log n)</span>。</p>
<p><span class="math inline">11</span>、多项式多点求值</p>
<p><del>事情好像更加毒瘤了。</del></p>
<p>我们可以利用<span class="math inline">\rm FFT</span>在<span
class="math inline">O(n\log n)</span>的时间内求出<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>在<span
class="math inline">n</span>个单位复数根处的值。那么我们自然还很好奇这样的一个问题：如果我随意给出<span
class="math inline">n</span>个点，有什么快速的方法可以求得它的值吗？答案是肯定的，利用下面的方法，我们可以在<span
class="math inline">O(n\log^2 n)</span>的时间内求出一个<span
class="math inline">n</span>次多项式在任意<span
class="math inline">n</span>个点处的值。</p>
<p>首先给出一个简单的结论。回顾之前的多项式除法，对于<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，<span
class="math inline">f(x_0)</span>的值就是：</p>
<p><span class="math display">
f(x_0)=f\bmod (x-x_0)
</span></p>
<p>这个应该很好证明，<span class="math inline">x-x_0</span>在<span
class="math inline">x=x_0</span>时值为<span
class="math inline">0</span>，因此它的倍数在求<span
class="math inline">x_0</span>时都为<span
class="math inline">0</span>，都没有影响，就只剩下一个常数，那就是答案。</p>
<p>现在的问题，就转化成对于下标集合为<span
class="math inline">\{0,1,2,...,n-1\}</span>的数组<span
class="math inline">a</span>，我们希望快速求得<span
class="math inline">f\bmod (x-a_i)</span>的值，其中<span
class="math inline">i=0,1,2,...,n-1</span>。</p>
<p>此时我们不妨考虑一下我们的老朋友分治。能否通过进行一些简单的处理，就能将<span
class="math inline">f</span>变成两个<span
class="math inline">\frac{n}{2}</span>次多项式递归求解呢？答案依然是肯定的。我们以左半部分为例，考虑将<span
class="math inline">f</span>变成：</p>
<p><span class="math display">
f\bmod \prod_{i=0}^{\frac{n}{2}-1}(x-a_i)
</span></p>
<p>这样的答案是不变的，因为在<span
class="math inline">x</span>等于左半部分任意的<span
class="math inline">a</span>值时，后面的连乘结果为<span
class="math inline">0</span>，没有影响，因此其倍数也不会有影响，而这式子是一个<span
class="math inline">\frac{n}{2}+1</span>次的多项式，<span
class="math inline">f</span>对其取模以后就得到了<span
class="math inline">\frac{n}{2}</span>次的多项式。对于右半部分，显然也是一样的。</p>
<p>再考虑如何快速求那个连乘。显然这是一个分治<span
class="math inline">\rm FFT</span>可以解决的问题，我们不妨先用<span
class="math inline">O(n\log^2
n)</span>的时间预处理出每一层的连乘，接着再做一遍上述分治做法，我们在每一层的复杂度就是<span
class="math inline">O(n\log n)</span>，解得<span
class="math inline">T(n)=O(n\log^2 n)</span>。</p>
<p><span class="math inline">12</span>、多项式多点插值</p>
<p>我们既然已经知道如何多点求值，自然也会好奇如何进行多点插值。这当然也是可以快速做到的，复杂度也是<span
class="math inline">O(n\log^2 n)</span>。不过其过程会更加复杂一些。</p>
<p>假设我们已经知道<span
class="math inline">n</span>个互不相同的点值<span
class="math inline">(x_0,y_0),(x_1,y_1),...,(x_{n-1},y_{n-1})</span>，那么由这<span
class="math inline">n</span>个点插值出来的多项式一定是唯一的。那么我们不妨假设我们可以构造<span
class="math inline">n</span>次多项式<span
class="math inline">\ell_i</span>，满足当<span
class="math inline">x</span>取<span
class="math inline">x_i</span>时值为<span
class="math inline">1</span>，取<span class="math inline">x_j(j\neq
i)</span>时值为<span
class="math inline">0</span>，那么显然这个多项式就是：</p>
<p><span class="math display">
f=\sum_{i=0}^{n-1}\ell_i y_i
</span></p>
<p>现在来考虑怎么构造它，这其实非常简单，只需：</p>
<p><span class="math display">
\ell_i=\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}
</span></p>
<p>发现当<span class="math inline">x</span>取<span
class="math inline">x_j(j\neq i)</span>时分子必有一个为<span
class="math inline">0</span>，因此值为<span
class="math inline">0</span>。取<span
class="math inline">x_i</span>时分母分子相互抵消，答案就为<span
class="math inline">1</span>。于是我们有：</p>
<p><span class="math display">
f=\sum_{i=0}^{n-1}\frac{y_i}{\prod_{j\neq i}(x_i-x_j)}*\prod_{j\neq
i}(x-x_j)
</span></p>
<p>直接根据定义计算显然是<span
class="math inline">O(n^2)</span>的，我们来考虑一下怎么做会更快。</p>
<p>我们先来计算<span class="math inline">\prod_{j\neq
i}(x_i-x_j)</span>这一部分如何。我们考虑计算出<span
class="math inline">n+1</span>次多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
g=\prod_{i=0}^{n-1}(x-x_i)
</span></p>
<p>这可以用分治<span class="math inline">\rm FFT</span>在<span
class="math inline">O(n\log^2 n)</span>的时间内解决。那么对于每一个<span
class="math inline">i</span>，我们就是要求：</p>
<p><span class="math display">
\frac{g(x_i)}{x-x_i}
</span></p>
<p>可是这个式子分子分母都是<span
class="math inline">0</span>啊…这怎么办办…这时我们的救星出现了，它叫做洛必达法则：</p>
<blockquote>
<p>对于函数<span class="math inline">f(x)</span>，<span
class="math inline">g(x)</span>，如果当<span class="math inline">x\to
a</span>时，有<span class="math inline">f(x)\to 0</span>，<span
class="math inline">g(x)\to 0</span>，那么有<span
class="math inline">\frac{f(a)}{g(a)}=\frac{f&#39;(a)}{g&#39;(a)}</span></p>
</blockquote>
<p>这其实也不难理解，两个趋近于<span
class="math inline">0</span>的数相除，我们用它们的变化率相除作为结果应该很自然。那么我们就可以利用洛必达法则，而<span
class="math inline">(x-x_i)&#39;=1</span>，于是我们对于<span
class="math inline">i</span>，要求的值就是<span
class="math inline">g&#39;(x_i)</span>。于是我们利用多项式多点求值，求出这<span
class="math inline">n</span>个答案，这样也是<span
class="math inline">O(n\log^2n)</span>的。</p>
<p>现在我们已经解决了第一部分，不妨用<span
class="math inline">v_i=\frac{y_i}{\prod_{j\neq
i}(x_i-x_j)}</span>代替原来这一长串。于是我们现在要求的是：</p>
<p><span class="math display">
\prod_{i=0}^{n-1}\Big(v_i*\prod_{j\neq i}(x-x_j)\Big)
</span></p>
<p>又到我们的老朋友出场了，我们再次利用分治来解决问题。我们先递归求解左右两半的子问题，接着以左半部分为例，不难发现我们需要的贡献就是左半部分的答案<span
class="math inline">*\prod_{i=\frac{n}{2}}^{n-1}(x-x_i)</span>，因为所有左半部分都是需要乘以它的。这又是一个分治<span
class="math inline">\rm FFT</span>的形式，于是先用<span
class="math inline">O(n\log^2
n)</span>的时间处理好，那么我们的每一层就是<span
class="math inline">O(n\log n)</span>的。解得<span
class="math inline">T(n)=O(n\log^2 n)</span>，我们终于解决了问题。</p>
<p><span class="math inline">13</span>、多项式三角函数</p>
<p>毒瘤<span class="math inline">ing</span>…</p>
<p>多项式三角函数是这样一个问题，给你一个<span
class="math inline">n</span>次多项式<span
class="math inline">f</span>，满足<span
class="math inline">f_0=0</span>，你需要求两个<span
class="math inline">n</span>次多项式<span
class="math inline">g</span>和<span
class="math inline">h</span>，满足：</p>
<p><span class="math display">
g\equiv \cos f(\bmod x^n),h\equiv \sin f(\bmod x^n)
</span></p>
<p><span class="math inline">\cos</span>和<span
class="math inline">\sin</span>是最基本的三角函数，知道它们就可以知道所有三角函数。我们来考虑如何解决这个问题，从优美的欧拉公式入手：</p>
<p><span class="math display">
e^{ix}=\cos(x)+i\sin(x)
</span></p>
<p>我们将多项式<span class="math inline">f</span>代入公式中，得到：</p>
<p><span class="math display">
e^{if}=\cos f+i\sin f
</span></p>
<p>那么我们可以将其代入复数域内计算，先将所有系数移到虚部再进行<span
class="math inline">\exp</span>得到结果，将得到的结果取实部和虚部即可。因为<span
class="math inline">f_0=0</span>，因此<span
class="math inline">if_0=0</span>，可以进行<span
class="math inline">\exp</span>。</p>
<p>虽然需要在复数域内计算，但是多项式三角函数应该也是可以取模的，我们考虑对实部和虚部的系数分别取模，把每次卷积运算拆做四次，再将贡献算入结果的实部或虚部即可。</p>
</body>
</html>
