<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>本来开头两道题写得挺快的，然后第三题想了一会儿胡出一个scc计算gcd的做法，写了一发凭借信仰交了上去结果一发pp了？然后第四题沙雕了想了很久才会，于是罚时瞬间变多。结果后面两题都没时间看了，赛后感觉e题考场上还是可做的…</p>
<p>最后自豪的成为c题fst的一员，因为naive写萎了一个地方。</p>
<p><a
href="http://codeforces.com/contest/1137/problems">题目链接</a></p>
<h3 id="a.-skyscrapers">A. Skyscrapers</h3>
<p>题意：给定一个<span class="math inline">n\times
m</span>的矩阵，对于所有<span class="math inline">1\leq i\leq n,1\leq
j\leq m</span>，计算将第<span class="math inline">i</span>行及第<span
class="math inline">j</span>列共同离散化并保持第<span
class="math inline">i</span>行元素之间相对大小不变、第<span
class="math inline">j</span>列元素之间相对大小不变至少需要几个不同的值。<span
class="math inline">n,m\leq 1000</span>。</p>
<p>题解：签到题，首先对每一行和每一列单独离散化。对于第<span
class="math inline">i</span>行和第<span
class="math inline">j</span>列，由于除了交点之外其他元素之间无影响，因此只要把离散化后的两个数组交点的位置对齐并计算长度即可。复杂度<span
class="math inline">O(nm\log nm)</span>。</p>
<h3 id="b.-camp-schedule">B. Camp Schedule</h3>
<p>题意：给定两个<span class="math inline">01</span>字符串<span
class="math inline">s</span>、<span
class="math inline">t</span>，求一个<span
class="math inline">s</span>的重新排列使得<span
class="math inline">t</span>作为子串出现在<span
class="math inline">s</span>中的次数最大。<span
class="math inline">|s|,|t|\leq 500000</span>。</p>
<p>题解：更签到的题。由于可以将<span
class="math inline">s</span>随意重新排列因此只需保留<span
class="math inline">s</span>中<span class="math inline">0</span>和<span
class="math inline">1</span>的个数。考虑开头设为<span
class="math inline">t</span>一定最优（如果可以的话），接下来想要出现新的<span
class="math inline">t</span>，可以利用<span
class="math inline">t</span>的最长border尽量少用一些字符。那么可以用kmp或者别的方法求出<span
class="math inline">t</span>的最长border，之后只要贪心放就可以了。复杂度<span
class="math inline">O(|s|+|t|)</span>。</p>
<h3 id="c.-museums-tour">C. Museums Tour</h3>
<p>题意：有一张<span class="math inline">n</span>个点<span
class="math inline">m</span>条边的有向图，每个点有一个博物馆并且走一条边需要恰好一天。这个世界一周有<span
class="math inline">d</span>天，博物馆每周的开放情况是一样的。现在告诉你每个点的博物馆一周内的开放情况（星期几是否开放），希望你求出在一周中的第<span
class="math inline">1</span>天从<span
class="math inline">1</span>号点出发最多能参观几个不同的博物馆。<span
class="math inline">n,m\leq 100000,d\leq 50</span>。</p>
<p>题解：这题什么都好就是pretest太弱了…容易想到先将原图分解为若干个强连通分量。先考虑每个强连通分量内部的情况，易知对于一个强连通分量中的每个点<span
class="math inline">x</span>，都存在一个<span
class="math inline">d</span>的因子<span
class="math inline">c</span>，使得假如能在星期<span
class="math inline">a</span>到达点<span
class="math inline">x</span>，那么一定能在星期<span
class="math inline">(a+c)\bmod d</span>到达<span
class="math inline">x</span>（这里的星期从<span
class="math inline">0</span>开始标号）。其中<span
class="math inline">c</span>在数值上等于<span
class="math inline">d</span>以及强连通分量内所有环的长度的最大公约数。此时我们不妨将强连通分量内的某个点设为关键点，假设在星期<span
class="math inline">0</span>从这个点出发，那么对于每个强连通分量内的点来说，都存在一个<span
class="math inline">[0,c)</span>之间的数<span
class="math inline">e</span>使得<span
class="math inline">e</span>是最小的满足能在星期<span
class="math inline">e</span>到达该点的数字。不妨将每个点的<span
class="math inline">e</span>值记为它的<span
class="math inline">id</span>。</p>
<p>那么首先我们假设我们已经知道了每个强连通分量的<span
class="math inline">c</span>，考虑如何进行<span
class="math inline">dp</span>。我们可以设<span
class="math inline">f_{i,j}</span>表示到达标号为<span
class="math inline">i</span>的强连通分量，且如果走到这个强连通分量中<span
class="math inline">id</span>为<span
class="math inline">0</span>的点时最小为星期<span
class="math inline">j</span>，那么在之前能参观的最多的博物馆数目。转移方程应该不难得出，只要注意<span
class="math inline">j</span>这一维在转移时应该如何变化即可。</p>
<p>最后考虑如何对每个强连通分量计算<span
class="math inline">c</span>。一个简单的方法是从状态<span
class="math inline">x,0</span>（可以在星期<span
class="math inline">0</span>到达<span
class="math inline">x</span>）开始dfs（只经过强连通分量内部的边），找出所有能到的状态。那么<span
class="math inline">c</span>以及每个点的<span
class="math inline">id</span>就不难得出了。复杂度<span
class="math inline">O((n+m)d)</span>。</p>
<h3 id="d.-cooperative-game">D. Cooperative Game</h3>
<p>题意：交互题。有<span
class="math inline">10</span>个小朋友在一个“<span
class="math inline">\rho</span>”上玩游戏。“<span
class="math inline">\rho</span>”是由<span
class="math inline">t+c</span>个点组成的，每个点只有一条出边。从起点开始有一条长度为<span
class="math inline">c</span>的链，链的尾端指入一个长度为<span
class="math inline">c</span>的环，其中指向的那个点就是终点。现在小朋友不知道<span
class="math inline">t</span>和<span
class="math inline">c</span>的值，但他们可以进行不超过<span
class="math inline">3(t+c)</span>次移动，每次可以令任意个不同的人向出边走一步，走完后告诉你哪些小朋友在一个点上。你要让所有小朋友都到达终点。</p>
<p>题解：学过pollard rho的应该都对这道题感到熟悉。pollard
rho有两种判圈的方法——floyd和倍增。虽然倍增比较常用但是这道题更适用floyd判圈。</p>
<p>首先只移动<span class="math inline">0</span>和<span
class="math inline">1</span>，每次令<span
class="math inline">0</span>走两步，令<span
class="math inline">1</span>走一步。可知当它们相遇时一定都走入了环中。那么此时再令<span
class="math inline">0</span>不停走，直到再和<span
class="math inline">1</span>相遇，那么就可以知道环的长度<span
class="math inline">c</span>。</p>
<p>此时令<span class="math inline">2</span>向前走<span
class="math inline">c</span>步，再将<span class="math inline">2\sim
9</span>一起移动，直到<span class="math inline">2</span>和<span
class="math inline">3\sim
9</span>相遇，可知他们一定都在终点。最后令<span
class="math inline">0</span>和<span
class="math inline">1</span>一起走到和<span class="math inline">2\sim
9</span>相遇即可。</p>
<p>直接这样做可能会导致交互次数过多，但是可以发现<span
class="math inline">2</span>先走的<span
class="math inline">c</span>步可以和<span
class="math inline">0</span>同时进行，于是就可以在次数限制之内完成了。</p>
<h3 id="e.-train-car-selection">E. Train Car Selection</h3>
<p>题意：维护一个数组，支持这些操作：</p>
<p><span class="math inline">1</span>、在前端塞入<span
class="math inline">k</span>个<span class="math inline">0</span>。</p>
<p><span class="math inline">2</span>、在后端塞入<span
class="math inline">k</span>个<span class="math inline">0</span>。</p>
<p><span
class="math inline">3</span>、对于数组中每个数，假设它是数组的第<span
class="math inline">i</span>个，那么令它的值加上<span
class="math inline">b+s(i-1)</span>。</p>
<p>每次操作完后，询问数组中的最小值以及最左边的最小值的位置。</p>
<p>操作个数<span class="math inline">q \leq 300000</span>。</p>
<p>题解：首先可以发现向数组前端塞入<span
class="math inline">0</span>挺滑稽的，因为永远是最晚插入的最前面一个比较小。于是可以将前后分开维护，每次将前后的答案取<span
class="math inline">\min</span>即可。于是只关注如何维护后面。</p>
<p>那么可以发现对于同时塞入的一段，第一个数永远是这一段中最小的，于是可以只保留第一个数。那么或许可以维护一个递减的单调栈，因为后面的数比前面大肯定没救了。但是可以发现在加上一个一次函数后单调栈可能不一定单调了。这时我们发现对于栈中的点，可以以数组下标为第一维当前值为第二维表示成一个点集。可以发现一定是形成一个下凸壳比较优，否则中间的点一定不会成为最小值。从值单调变成斜率单调以后即使加上一个一次函数也是满足单调性的，于是就可以直接做了。复杂度<span
class="math inline">O(q)</span>。</p>
<h3 id="f.-matches-are-not-a-childs-play">F. Matches Are Not a Child’s
Play</h3>
<p>题意：给定一棵<span
class="math inline">n</span>个点的树，每个点点权互不相同。定义树的消除规则为每次选择点权最小的度数为<span
class="math inline">1</span>的点消除。有三种操作：</p>
<p><span
class="math inline">1</span>、将某个点的点权设为当前最大点权<span
class="math inline">+1</span>。</p>
<p><span
class="math inline">2</span>、询问假如要消除整棵树，那么某个点是第几个被消除的。</p>
<p><span
class="math inline">3</span>、询问假如要消除整棵树，那么两个点哪个先被消除。</p>
<p><span class="math inline">n\leq 200000</span>，操作个数<span
class="math inline">q\leq 200000</span>。</p>
<p>题解：第三个操作显然是滑稽我们不管它。此时我们假设之前点权最大的点是<span
class="math inline">y</span>，现在改为了<span
class="math inline">x</span>，那么对消除序列有什么修改。可以画图考虑发现只是将树链<span
class="math inline">x,y</span>之间的点按从<span
class="math inline">y</span>到<span
class="math inline">x</span>的顺序移动到了最后，其他点的相对消除顺序是不变的。那么我们可以将这个操作等价的改为将树链<span
class="math inline">x,y</span>的点权赋值为一个比较大的公差为<span
class="math inline">1</span>的等差数列，修改点权的同时维护权值线段树就可以知道每个点的排名。</p>
<p>有一种方法是使用lct，将权值为一段连续等差数列的链合并在一棵<span
class="math inline">Splay</span>内。每次相当于设根为<span
class="math inline">y</span>，然后将<span
class="math inline">x</span>向上<span
class="math inline">access</span>，每次轻重链切换时顺便修改权值线段树就可以了。只是需要注意打标记时下传的顺序，因为赋值和翻转是同时存在的<del>（我才不会说我因为标记下传的规则调了一年呢）</del>。复杂度<span
class="math inline">O(n\log^2 n)</span>。</p>
</body>
</html>
