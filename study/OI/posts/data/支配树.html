<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>为了方便本文的叙述，做出如下可能不严谨的定义：</p>
<p>对于一棵树，我们可以用<span
class="math inline">[x,y]</span>简洁的表示从<span
class="math inline">x</span>到<span
class="math inline">y</span>的路径上的所有点组成的集合，假如我们希望这个集合不包含<span
class="math inline">x</span>或<span
class="math inline">y</span>，只要将闭区间改为开区间即可。如<span
class="math inline">[x,y)</span>表示从<span
class="math inline">x</span>到<span
class="math inline">y</span>的路径上的所有点（不包含<span
class="math inline">y</span>）组成的集合。</p>
<p>我们从一道简单的板子题（在读完这篇文章以后就是了）开始：</p>
<p>给定一个<span class="math inline">n</span>个点，<span
class="math inline">m</span>条边的有向图<span
class="math inline">G</span>，以及一个出发点<span
class="math inline">r</span>。询问<span
class="math inline">q</span>次，每次给定点<span
class="math inline">x</span>，<span
class="math inline">y</span>，保证从<span
class="math inline">r</span>出发可以到达<span
class="math inline">x</span>。问从<span
class="math inline">r</span>出发到达<span
class="math inline">x</span>的所有路径是否都需要经过<span
class="math inline">y</span>。</p>
<p><span class="math inline">n,m,q\leq 10^5</span>。</p>
<p>为了解决这个问题，我们定义有向图上的<strong>支配</strong>关系：对于一个固定的出发点<span
class="math inline">r</span>，如果从<span
class="math inline">r</span>出发到达<span
class="math inline">x</span>的所有路径都需要经过<span
class="math inline">y</span>，则称<span
class="math inline">y</span>是<span
class="math inline">x</span>的<strong>支配点</strong>，即<span
class="math inline">y</span><strong>支配</strong><span
class="math inline">x</span>。特别的，我们认为<span
class="math inline">x</span>不是<span
class="math inline">x</span>的支配点。</p>
<p>我们来研究一下支配关系有哪些性质：</p>
<p>首先，我们将以<span class="math inline">r</span>为根的<span
class="math inline">dfs</span>树建立出来。容易发现，对于任意一个点<span
class="math inline">x</span>，它的所有支配点只可能是它的祖先——显然，对于不是它的祖先的任意一个点<span
class="math inline">y</span>，我们从<span
class="math inline">r</span>通过树边到达<span
class="math inline">x</span>就不需要经过<span
class="math inline">y</span>。</p>
<p>接着我们假设<span class="math inline">y</span>是<span
class="math inline">x</span>的支配点中深度最大的（即距离<span
class="math inline">x</span>最近的），那么还可以发现：对于<span
class="math inline">z\neq y</span>，<span
class="math inline">z</span>是<span
class="math inline">x</span>的支配点当且仅当<span
class="math inline">z</span>是<span
class="math inline">y</span>的支配点。</p>
<p>证明如下：</p>
<p>首先证明充分性。如果<span class="math inline">y</span>支配<span
class="math inline">x</span>，<span
class="math inline">z</span>支配<span
class="math inline">y</span>，那么假设<span
class="math inline">z</span>不支配<span
class="math inline">x</span>，即存在一条路径不经过<span
class="math inline">z</span>。那么显然由于这条路径必定经过<span
class="math inline">y</span>，于是我们就找到了一条不经过<span
class="math inline">z</span>到达<span
class="math inline">y</span>的路径，这与前提条件矛盾，于是假设不成立，充分性得证。</p>
<p>再证明必要性。如果<span class="math inline">y</span>支配<span
class="math inline">x</span>，<span
class="math inline">z</span>不支配<span
class="math inline">y</span>，显然可以找到一条路径不经过<span
class="math inline">z</span>而到达<span
class="math inline">y</span>。此时由于<span
class="math inline">y</span>是深度最大的<span
class="math inline">x</span>的支配点，因此沿着树边一直走到<span
class="math inline">x</span>，必定不会经过<span
class="math inline">z</span>，于是<span
class="math inline">z</span>就不可能是<span
class="math inline">x</span>的支配点。</p>
<p>于是我们就可以知道，对于任意一个点<span
class="math inline">x</span>，我们只要找到它深度最大的支配点<span
class="math inline">y</span>，其余的支配点就都是<span
class="math inline">y</span>的支配点。不难发现，这样的支配关系形成了一个类似树的结构，将之前所说的<span
class="math inline">y</span>当作<span
class="math inline">x</span>的父亲的话，那么<span
class="math inline">x</span>的所有支配点就是这棵树上它的祖先。我们将这棵树叫做<strong>支配树</strong>，将这样的<span
class="math inline">y</span>记为<span
class="math inline">idom(x)</span>。</p>
<p>那么问题来了，如何求出<span
class="math inline">idom(x)</span>呢？</p>
<p>为了解决这个问题，我们先定义一个叫做<strong>半支配</strong>的东西：</p>
<p>对于任意一个点<span class="math inline">x</span>，从<span
class="math inline">y</span>出发，只经过不是<span
class="math inline">x</span>的祖先的点就可以到达<span
class="math inline">x</span>（不包含<span
class="math inline">x</span>，<span
class="math inline">y</span>），则称<span
class="math inline">y</span>是<span
class="math inline">x</span>的<strong>半支配点</strong>，即<span
class="math inline">y</span><strong>半支配</strong><span
class="math inline">x</span>。</p>
<p>首先，我们可以发现<span
class="math inline">x</span>的深度最小的半支配点一定是<span
class="math inline">x</span>的祖先。因为假设<span
class="math inline">x</span>的深度最小的半支配点<span
class="math inline">y</span>不是<span
class="math inline">x</span>的祖先，那么显然我们可以沿着树边往回走，一直走到某个<span
class="math inline">x</span>的祖先<span
class="math inline">z</span>上。这其间肯定不会经过除<span
class="math inline">z</span>以外的<span
class="math inline">x</span>的祖先点，于是<span
class="math inline">z</span>的深度比<span
class="math inline">y</span>小，且也是<span
class="math inline">x</span>的半支配点，于是假设不成立，得证。</p>
<p>接着，如果<span class="math inline">y</span>是<span
class="math inline">x</span>的深度最小的半支配点，那么树上路径<span
class="math inline">(x,y)</span>中的点就显然不是<span
class="math inline">x</span>的支配点——因为从<span
class="math inline">y</span>出发存在一条路不经过它们而到达<span
class="math inline">x</span>。我们将这样的<span
class="math inline">y</span>记为<span
class="math inline">sdom(x)</span>。</p>
<p>我们来考虑如果求得了半支配点，那么如何求支配点。考虑对于一个点<span
class="math inline">x</span>，树上路径<span
class="math inline">(x,sdom(x))</span>中的点一定不是<span
class="math inline">x</span>的支配点。并且对于任意一个<span
class="math inline">x</span>的祖先<span
class="math inline">y</span>，树上路径<span
class="math inline">(y,sdom(y))</span>中的点也一定不是<span
class="math inline">x</span>的支配点。反之，如果某个<span
class="math inline">x</span>的祖先<span
class="math inline">z</span>不被<span
class="math inline">(x,sdom(x))</span>和任何一个<span
class="math inline">(y,sdom(y))</span>包含，那么<span
class="math inline">z</span>一定是<span
class="math inline">x</span>的支配点——否则一定会存在一条不经过<span
class="math inline">z</span>的路径<span
class="math inline">S</span>到达<span
class="math inline">x</span>，<span
class="math inline">S</span>中一定存在两个<span
class="math inline">x</span>的祖先<span
class="math inline">a,b</span>使得树上路径<span
class="math inline">(a,b)</span>经过<span
class="math inline">z</span>而<span
class="math inline">a,b</span>之间不经过其它<span
class="math inline">x</span>的祖先，于是<span
class="math inline">z</span>一定会被某个区间包含。</p>
<p>于是<span
class="math inline">idom(x)</span>就是不被如上所述的这些区间包含的<span
class="math inline">x</span>的祖先中深度最大的。考虑递归解决这个问题，如果<span
class="math inline">y</span>是<span
class="math inline">[x,sdom(x))</span>中<span
class="math inline">sdom(y)</span>的深度最小的，那么如果<span
class="math inline">sdom(y)</span>就是<span
class="math inline">sdom(x)</span>，显然<span
class="math inline">sdom(x)</span>不会被任何区间包含了，那么<span
class="math inline">idom(x)</span>就是<span
class="math inline">sdom(x)</span>。否则我们就去掉区间<span
class="math inline">(x,sdom(x))</span>并求对于<span
class="math inline">y</span>来说这个问题的答案即可——而这就是<span
class="math inline">idom(y)</span>，已经求好了。</p>
<p>好，现在解决最后一个问题，如何求出<span
class="math inline">sdom(x)</span>。分两种情况讨论：</p>
<p><span
class="math inline">1)</span>最后一条边为前向边或树边。显然另一端就是<span
class="math inline">x</span>的祖先，路径必须结束。这种情况可以直接得到半支配点。</p>
<p><span
class="math inline">2)</span>最后一条边为横插边或后向边，设走到的点为<span
class="math inline">y</span>，而<span
class="math inline">x</span>，<span class="math inline">y</span>在<span
class="math inline">dfs</span>树上的<span
class="math inline">lca</span>为<span
class="math inline">z</span>。由于<span
class="math inline">lca</span>为<span
class="math inline">z</span>，因此树上路径<span
class="math inline">[x,z)</span>中的点一定无法到达<span
class="math inline">[y,z)</span>中的点，于是对于<span
class="math inline">[y,z)</span>的<span
class="math inline">sdom</span>来说，不会有经过<span
class="math inline">[x,z)</span>中的点的路径，那么显然树上路径<span
class="math inline">[y,z)</span>中的点对于<span
class="math inline">x</span>来说都是合法的。于是用树上路径<span
class="math inline">[y,z)</span>中的点的<span
class="math inline">sdom</span>来更新<span
class="math inline">sdom(x)</span>即可。可以发现沿着时间戳反向求<span
class="math inline">sdom</span>的话，我们求<span
class="math inline">sdom</span>的顺序就不会冲突。</p>
<p>于是我们就解决了文章开头提到的那个问题。至于具体的实现，我们在反向求<span
class="math inline">sdom</span>的过程中可以用带权并查集维护一段树上路径的<span
class="math inline">sdom</span>最小值，在求完一个点的<span
class="math inline">sdom</span>以后将它的儿子与它合并即可。这样每次查询时并查集维护的恰好就是我们需要的那一条链。至于求<span
class="math inline">idom</span>的过程，我们需要知道<span
class="math inline">[x,sdom(x))</span>的信息，于是将请求接入<span
class="math inline">sdom(x)</span>的链表中。每一次求完<span
class="math inline">x</span>的<span
class="math inline">sdom</span>后，我们扫描其父亲的请求链表，对于链表中每一个<span
class="math inline">y</span>，可以发现带权并查集此时维护的就是我们要查询的区间<span
class="math inline">[y,sdom(y))</span>，直接从带权并查集上得知<span
class="math inline">sdom</span>最小的为哪一个并存下来并清空链表，在最后求<span
class="math inline">idom</span>时直接用即可。</p>
<p>时间复杂度<span class="math inline">O((n+m)\log n)</span>。</p>
<p>有向图上还有类似的支配边的关系，容易发现只有树边能成为支配边。且如果一条边<span
class="math inline">y\to x</span>为<span
class="math inline">x</span>的支配边，需要<span
class="math inline">y</span>为<span
class="math inline">x</span>的支配点，且对于所有有非树边指向<span
class="math inline">x</span>的点<span
class="math inline">z</span>，都有<span
class="math inline">x</span>支配<span class="math inline">z</span>。</p>
<p>有向图上还有割点、桥、点双、边双的定义。不过还是下次填坑吧…</p>
<p>参考链接：[https://zhuanlan.zhihu.com/p/30432617][1]</p>
</body>
</html>
