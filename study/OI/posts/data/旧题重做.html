<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h3 id="zjoi2016小星星">[ZJOI2016]小星星</h3>
<p>容斥是官方做法，不过用集合并卷积也可以推出同样的dp式子。</p>
<p>树形dp，令<span class="math inline">f_{x,i,S}</span>表示以<span
class="math inline">x</span>为根的子树，<span
class="math inline">x</span>映射到<span
class="math inline">i</span>，子树全体映射到<span
class="math inline">S</span>的合法方案数。 考虑给当前的<span
class="math inline">x</span>添加一个以<span
class="math inline">y</span>为根的子树，令新的以<span
class="math inline">x</span>为根的<span
class="math inline">dp</span>数组为<span
class="math inline">f&#39;</span>，有：</p>
<p><span class="math display">
f&#39;_{x,i,S}=\sum_{(i,j)\in E}\sum_{A\cup B=S,A\cap
B=\emptyset}f_{x,i,A}f_{y,j,B}
</span></p>
<p>枚举合法的<span
class="math inline">i,j</span>，余下的就是一个看上去像子集卷积的东西。</p>
<p>然而最终只需要<span
class="math inline">S</span>为全集的方案，如果<span
class="math inline">A</span>与<span
class="math inline">B</span>有交，那么<span class="math inline">A\cup
B</span>必然小于新的<span
class="math inline">x</span>的子树大小，最终不可能对答案产生贡献。</p>
<p>于是考虑去掉<span class="math inline">A\cap
B=\emptyset</span>的限制，仍然保证答案的正确性，转化为集合并卷积:</p>
<p><span class="math display">
f&#39;_{x,i,S}=\sum_{(i,j)\in E}\sum_{A\cup B=S}f_{x,i,A}f_{y,j,B}
</span></p>
<p>于是令<span class="math inline">\hat f</span>表示<span
class="math inline">f</span>对最后一维做莫比乌斯变换之后的结果，有：</p>
<p><span class="math display">
\hat f&#39;_{x,i,S}=\hat f_{x,i,S}\sum_{(i,j)\in E}\hat f_{y,j,S}
</span></p>
<p>初始状态下<span
class="math inline">f_{x,i,S}=[S=\{i\}]</span>，很容易得到莫比乌斯变换之后的结果。dp中不需要进行反演，保留莫比乌斯变换后的形式计算即可。</p>
<p>最后将根的全集方案数用莫比乌斯逆变换的公式算出来即可，复杂度也是<span
class="math inline">O(n^32^n)</span>。</p>
<h3 id="cts2019重复">[CTS2019]重复</h3>
<p>我们记<span class="math inline">t^k</span>表示将字符串<span
class="math inline">t</span>重复<span
class="math inline">k</span>次形成的字符串。</p>
<p>显然，我们先正难则反，统计不包含任何有意义字符串（简称为性质<span
class="math inline">A</span>）的无限重复串的个数。</p>
<p>根据题意，可以设置一个只含有一个串<span
class="math inline">s</span>的AC自动机。对于一个状态<span
class="math inline">i</span>，有<span
class="math inline">k_i</span>个字符可以转移到非根节点，假设是<span
class="math inline">c_{i,1},c_{i,2},\dots,c_{i,k_i}</span>，且按照升序排序，剩余字符只能转移到根。那么不难发现，满足性质<span
class="math inline">A</span>的串只能从<span class="math inline">\geq
c_{i,k_i}</span>的字符中进行转移（称为合法转移），粗略考虑，发现我们需要统计的是长度为<span
class="math inline">m</span>的字符串中，重复无限次仍然始终走合法转移的字符串有多少。</p>
<p>然而重复无限次不太具有可操作性，进一步观察一个串重复无限次后，在自动机上的转移规律。我们令<span
class="math inline">trans_{x,s}</span>表示从状态<span
class="math inline">x</span>接受一个字符串<span
class="math inline">s</span>，最终会走到什么状态。可以发现这样一个事实：当<span
class="math inline">k</span>足够大的时候，必然有<span
class="math inline">trans_{0,t^k}=trans_{0,t^{k+1}}=trans_{0,t^{k+2}}=\cdots</span>，这是因为所有可能在<span
class="math inline">t^{k+1}</span>的后缀中出现的<span
class="math inline">s</span>的前缀一定被包含在<span
class="math inline">t^k</span>的后缀中了。因此，如果记<span
class="math inline">x=trans_{0,t^k}</span>，我们就有理由定义<span
class="math inline">trans_{0,t^\infty}=x</span>，于是，在<span
class="math inline">t</span>重复有限次之后，之后的转移都形如<span
class="math inline">x\to trans_{x,t[:1]}\to trans_{x,t[:2]}\to \cdots\to
x</span>，然后不断重复。</p>
<p>不难发现<span
class="math inline">trans_{x,t}=x</span>，还可以证明满足这一点的<span
class="math inline">x</span>是唯一的，因为如果满足这一点，那么就有<span
class="math inline">trans_{x,t^k}=x</span>，当<span
class="math inline">k</span>足够大时，<span
class="math inline">x</span>一定被包含在<span
class="math inline">t^k</span>的后缀中，于是就是唯一的。</p>
<p>另一个重要的事实：<span
class="math inline">t^\infty</span>满足性质<span
class="math inline">A</span>，当且仅当<span class="math inline">x\to
trans_{x,t[:1]}\to trans_{x,t[:2]}\to \cdots\to
x</span>都是合法转移。这是因为如果有一个有意义的串出现在了<span
class="math inline">t^\infty</span>中，它一定会出现无限多次，于是一定会在不断重复的<span
class="math inline">x\to trans_{x,t[:1]}\to trans_{x,t[:2]}\to \cdots\to
x</span>转移中出现，造成一个不合法的转移。</p>
<p>综上所述，我们可以先枚举<span
class="math inline">x</span>，统计所有满足<span
class="math inline">trans_{x,t}=x</span>的串中，满足性质<span
class="math inline">A</span>的串个数：令<span
class="math inline">dp_{i,j}</span>表示长度为<span
class="math inline">i</span>的满足<span
class="math inline">trans_{x,t}=j</span>，且都是合法转移的字符串<span
class="math inline">t</span>的数目。转移方程容易得到，最后<span
class="math inline">dp_{m,x}</span>就是答案。这个动态规划是<span
class="math inline">O(n^2m)</span>的，还是无法通过本题。</p>
<p>再观察合法转移的性质：由于只能从<span class="math inline">\geq
c_{i,k_i}</span>的字符中进行转移，因此每个点最多只有一个转移不走到根，也就是说，如果不走到根，那么合法转移的路径是唯一的。于是我们枚举从<span
class="math inline">x</span>开始，一直走合法转移，第一次走到根的步数<span
class="math inline">i</span>。令<span
class="math inline">dp_{i,j}</span>表示长度为<span
class="math inline">i</span>的满足<span
class="math inline">trans_{0,t}=j</span>，且都是合法转移的字符串<span
class="math inline">t</span>的数目。这种情况的答案就是<span
class="math inline">dp_{m-i,x}</span>。如果一次都没有回到根，这样的方案是唯一的，直接走就行。复杂度<span
class="math inline">O(nm)</span>。</p>
<h3 id="cts2019珍珠">[CTS2019]珍珠</h3>
<p>之前推的式子不够优雅！</p>
<p>一句话题意：求</p>
<p><span class="math display">
ans=n!\sum_{k=0}^{n-2m}[y^k][x^n]\bigg(\frac{e^x+e^{-x}}{2}+y\frac{e^x-e^{-x}}{2}\bigg)^D
</span></p>
<p>有了<span
class="math inline">y</span>的指标作为辅助，推式子的过程可以精简很多：</p>
<p><span class="math display">
ans=\frac{n!}{2^D}\sum_{k=0}^{n-2m}[y^k][x^n]\bigg((e^x+e^{-x})+y(e^x-e^{-x})\bigg)^D
</span></p>
<p><span class="math display">
=\frac{n!}{2^D}\sum_{k=0}^{n-2m}[y^k][x^n]\bigg((1+y)e^x+(1-y)e^{-x}\bigg)^D
</span></p>
<p><span class="math display">
=\frac{n!}{2^D}\sum_{k=0}^{n-2m}[y^k][x^n]\sum_{i=0}^D{D\choose
i}e^{(2i-D)x}(1+y)^i(1-y)^{D-i}
</span></p>
<p><span class="math display">
=\sum_{i=0}^D{D\choose
i}\frac{n!}{2^D}\sum_{k=0}^{n-2m}[y^k][x^n]e^{(2i-D)x}(1+y)^i(1-y)^{D-i}
</span></p>
<p>关键的一步是在枚举<span
class="math inline">i</span>以后，一个二元混合多项式<span
class="math inline">F(x,y)</span>被分离成<span
class="math inline">F_1(x)F_2(y)</span>的形式，于是<span
class="math inline">x</span>和<span
class="math inline">y</span>的部分可以分离，并且<span
class="math inline">x</span>的部分结果是显然的：</p>
<p><span class="math display">
ans=\sum_{i=0}^D{D\choose
i}\frac{n!}{2^D}\Big([x^n]e^{(2i-D)x}\Big)\Big(\sum_{k=0}^{n-2m}[y^k](1+y)^i(1-y)^{D-i}\Big)
</span></p>
<p><span class="math display">
ans=\sum_{i=0}^D{D\choose
i}\frac{(2i-D)^n}{2^D}\Big(\sum_{k=0}^{n-2m}[y^k](1+y)^i(1-y)^{D-i}\Big)
</span></p>
<p>到了这一步就可以用分治fft大法<span
class="math inline">O(n\log^2n)</span>解决问题了！但是如果想追求更好的做法，可以继续推导。下面关注对<span
class="math inline">f_i=\sum_{k=0}^{n-2m}[y^k](1+y)^i(1-y)^{D-i}</span>的求和：</p>
<p><span class="math display">
f_i=\sum_{j=0}^{i}[y^j](1+y)^i\sum_{k=0}^{n-2m-j}[y^k](1-y)^{D-i}
</span></p>
<p><span class="math display">
=\sum_{j=0}^{i}{i\choose j}\sum_{k=0}^{n-2m-j}(-1)^k{D-i\choose
k}=\sum_{j=0}^{i}{i\choose j}(-1)^{n-2m-j}{D-i-1\choose n-2m-j}
</span></p>
<p><span class="math display">
=i!(D-i-1)!\sum_{j=0}^{i}\frac{(-1)^{n-2m-j}}{j!(n-2m-j)!}\frac{1}{(i-j)!(D-1-n+2m-(i-j))!}
</span></p>
<p>最后就化成了一个卷积式，可以<span class="math inline">O(n\log
n)</span>解决问题。可以发现<span
class="math inline">(1+y)^k</span>和<span
class="math inline">(1-y)^k</span>并不完全对称，因为<span
class="math inline">(1-y)^k</span>的系数前缀和有好的封闭形式。</p>
</body>
</html>
