<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>很久以前，我在退役之后说过要在Codeforces上与你们再见。我回来了。</p>
<p>先写A-E的题解，F和G之后补。<del>先写一部分可以防止咕咕咕。</del></p>
<p>F已经补上，G的题解非常妙，我将单独开一篇来介绍。</p>
<h2 id="a.-avoiding-zero">A. Avoiding Zero</h2>
<p>重排一列数使得前缀和始终不为<span
class="math inline">0</span>，可能无解。</p>
<p>题解：和为<span
class="math inline">0</span>则显然无解，否则考虑分为正数和负数两部分，将和的绝对值大的那一部分放在前面，就不会出现前缀和为<span
class="math inline">0</span>了。</p>
<h2 id="b.-chess-cheater">B. Chess Cheater</h2>
<p>你有自己<span
class="math inline">n</span>场比赛的结果（赢或输），输的场不扣分，赢的场得一分，如果上一场也赢再得一分。你可以修改<span
class="math inline">k</span>场比赛的结果，使得自己总分最大。</p>
<p>题解：显然只需要把输改为赢。那么修改完之后赢的场次就是<span
class="math inline">\min\{cnt+k,n\}</span>，其中<span
class="math inline">cnt</span>为本来就赢得的场次。</p>
<p>然后只需要最小化连赢的场的段数。可以通过把两段连赢之间的输改成赢来减少一段。那么只要按照连赢段之间的距离升序排序尽量消除就可以了。</p>
<h2 id="c.-the-hard-work-of-paparazzi">C. The Hard Work of
Paparazzi</h2>
<p>有一个二维平面，从一点<span
class="math inline">(x_1,y_1)</span>走到另一点<span
class="math inline">(x_2,y_2)</span>所花的时间为<span
class="math inline">|x_1-x_2|+|y_1-y_2|</span>。有<span
class="math inline">n</span>个事件，第<span
class="math inline">i</span>个在时刻<span
class="math inline">t_i</span>在点<span
class="math inline">(x_i,y_i)</span>发生。你时刻<span
class="math inline">0</span>在<span
class="math inline">(1,1)</span>，问最多参与多少事件。事件发生时刻严格递增。<span
class="math inline">|x_i|,|y_i|\leq 500,n\leq 10^5</span>。</p>
<p>题解：比赛时居然没想到…老了老了。考虑朴素<span
class="math inline">dp</span>，<span
class="math inline">f_i</span>表示参与<span
class="math inline">i</span>号事件时之前最多参与了几个事件。普通的一次转移是<span
class="math inline">O(n)</span>的，但考虑如果时间差大于<span
class="math inline">2*|x|</span>就肯定能到了，因此前面最多只有<span
class="math inline">O(|x|)</span>个事件是需要逐一判断的。复杂度优化为<span
class="math inline">O(n|x|)</span>。</p>
<h2 id="d.-unshuffling-a-deck">D. Unshuffling a Deck</h2>
<p>你有一个长度为<span class="math inline">n</span>的排列<span
class="math inline">p</span>，每次可以将其分割为若干段，段内顺序不变，所有段之间顺序反转。给出不多于<span
class="math inline">n</span>次这样的操作将原排列排序。</p>
<p>题解：记录<span class="math inline">k</span>是排列中的第<span
class="math inline">a_k</span>个。如果对<span
class="math inline">k=1,2,\dots,n-1</span>，都有<span
class="math inline">a_k&lt;a_{k+1}</span>就排完了。否则找到某一个<span
class="math inline">a_k&gt;a_{k+1}</span>的<span
class="math inline">k</span>。</p>
<p>设<span class="math inline">k+1</span>之后连续递增的一段为<span
class="math inline">[a_{k+1},pos]</span>（即这个区间内<span
class="math inline">p_i=i-a_{k+1}+k+1</span>），将排列分割为<span
class="math inline">[1,a_{k+1}-1],[a_{k+1},pos],[pos+1,a_k],[a_k+1,n]</span>四段，用题中操作，操作完毕后<span
class="math inline">a_k+1=a_{k+1}</span>，即<span
class="math inline">k</span>与<span
class="math inline">k+1</span>连在了一起，同时不会破坏任何已经连在一起的对。不断重复上述操作即可。</p>
<p>##E. Xum</p>
<p>黑板上初始有一个奇数，每次可以选黑板上两个数（可重复），再写出它们的和或异或和，重复若干步写出<span
class="math inline">1</span>。限制比较宽松。</p>
<p>题解：我的做法是非标准的做法。考虑用线性基判定是否可以通过异或得到<span
class="math inline">1</span>，先加和几次自身扩充一下线性基，之后每次随机从线性基中得到两个数取和加入，不久就会出解。对于<span
class="math inline">2^k+1</span>的情况会比较苛刻，要先得到较大的倍数加入线性基中。</p>
<h2 id="f.-boring-card-game">F. Boring Card Game</h2>
<p>桌上有<span class="math inline">1,2,\dots,6n</span>标号的<span
class="math inline">6n</span>张连续牌，Alice和Bob玩游戏轮流取<span
class="math inline">3</span>张，Alice先取，每次取出位置连续的三张牌并将上下两堆牌合并。给出Alice最终拿到的所有牌的标号，复原一种可能的游戏过程，保证有解。<span
class="math inline">n\leq 200</span></p>
<p>题解：</p>
<p>先考虑问题的弱化版：取消轮流取的限制，允许某人反复取三张牌，先判断这个条件下是否有解。</p>
<p>那么考虑一个贪心：从左到右扫描牌，逐一加入栈中，如果加入后栈顶出现三张属于同一个人的牌，就视为进行了一次取走操作，将这三张牌弹出。</p>
<p>如果贪心算法最终能将栈清空，显然就得到了一组合法解。现在来进一步证明如果弱化版问题有合法解那么栈一定被清空。</p>
<p>对取牌轮数<span class="math inline">n</span>用数学归纳法。 <span
class="math inline">n=0</span>时显然成立。 假设<span
class="math inline">n=k</span>时成立。<span
class="math inline">n=k+1</span>时，对某种有解的情况，我们随意考虑它的某一个解，这个解的第一步取走的必定是标号连续的牌，设为<span
class="math inline">k,k+1,k+2</span>。如果我们先打破贪心规则取走这三张牌，由数学归纳法，剩下的牌可以通过贪心构造一个解。
进一步转化，可以发现如果将之后的若干不依赖于<span
class="math inline">k,k+1,k+2</span>三张牌被取走的前提就能取走的牌先于<span
class="math inline">k,k+1,k+2</span>被取走，也是合法的。因此我们换一种打破规则的方式，改成在<span
class="math inline">k,k+1,k+2</span>中的一些牌置于栈顶并可以取走时，如果并非<span
class="math inline">k,k+1,k+2</span>这一组合就不取走，直到<span
class="math inline">k,k+1,k+2</span>都出现在栈顶才取走它们（此时栈顶可能有<span
class="math inline">4-5</span>张属于同一人的牌），也能在之后合乎贪心的过程给出一个解。
最后，由于<span
class="math inline">k,k+1,k+2</span>是连续的，假设我们保留了本来可以取走的<span
class="math inline">a,b,k</span>不取走，<span
class="math inline">k+1,k+2</span>必定马上到来并将<span
class="math inline">k</span>带走，此时栈顶留下<span
class="math inline">a,b</span>，但是如果我们合乎规则操作，直接取走<span
class="math inline">a,b,k</span>，栈顶就剩下<span
class="math inline">k+1,k+2</span>，由于这些牌的归属者相同，对于之后的过程来说，除了标号<span
class="math inline">k+1,k+2</span>和<span
class="math inline">a,b</span>没有本质区别，因此原来能得出解此刻仍然可以得出解。<span
class="math inline">a,k,k+1</span>的情况也是类似的。而此时是完全符合贪心规则的。因此也就证明完毕了。</p>
<p>因此原问题有解的必要条件是栈能够清空，也就是得出一种弱化版的方案，现在再来分析一下该方案中每一组牌之间的依赖关系。可以得知，如果我们让三张牌对应到包含这三张牌编号的最小区间，那么任何两个区间之间只有无交和包含两种关系，因此可以建立一个森林，树中祖先的区间包含所有后代的区间。对于这三张牌，显然只有其子树对应的三张牌组取完才可以取。不难发现，对一组三张牌，尽管其后代中可能存在归属者相同的牌组，但由贪心的性质其儿子对应的归属者都是与自己的不同的。</p>
<p>重新考虑轮流取的限制，我们对森林的操作就变成了：只有所有叶子都已经被取走的节点可以被取走，且必须<span
class="math inline">Alice</span>的牌的点和<span
class="math inline">Bob</span>的牌的点轮流取走。考虑是否存在这样一个取走的序列。</p>
<p>首先，最后一组取走的牌一定是森林中某棵树的根。因此，如果所有根都是<span
class="math inline">Alice</span>的牌，就一定无解。那么下面只要说明森林里有一棵树的根属于<span
class="math inline">Bob</span>，就一定能找到一组解。</p>
<p>要取<span class="math inline">Alice</span>的节点时，假设没有<span
class="math inline">Alice</span>的节点作叶子，那么所有<span
class="math inline">Alice</span>和某个儿子<span
class="math inline">Bob</span>节点配对。但是<span
class="math inline">Bob</span>节点至少有一个根，不满足条件，因此有<span
class="math inline">Alice</span>叶子节点，随意取一个即可。</p>
<p>而要取<span class="math inline">Bob</span>的节点时，此时<span
class="math inline">Bob</span>的节点多一个。分两种情况：<span
class="math inline">Bob</span>的根只有一个和有多个。
如果有多个，假设没有<span
class="math inline">Bob</span>叶子，就令每个<span
class="math inline">Bob</span>点和某儿子<span
class="math inline">Alice</span>点配对，而<span
class="math inline">Alice</span>点少一个，必不可行。又由于<span
class="math inline">Bob</span>根多于一个，取走一个并不影响“存在至少一个<span
class="math inline">Bob</span>根”这一性质，因此随便取。
如果只有一个，那么再分类：
如果这个点有儿子，本来就不可取，直接利用结论随便取走一个叶子即可。
如果这个点没有儿子，且除了它以外没有别的树，它就是最后一个点，显然可以取走。如果没有儿子且还有别的树，一定是以<span
class="math inline">Alice</span>为根，不考虑这个点后的讨论和<span
class="math inline">Alice</span>相似，一定可以找到另一个<span
class="math inline">Bob</span>叶子。</p>
</body>
</html>
