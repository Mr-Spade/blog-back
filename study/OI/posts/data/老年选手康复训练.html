<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>学考考完了。虽然身为d类咸鱼选手还是要好好备战一下noi的。</p>
<p>从今天开始进行康复训练，不过白天应该还是要肝文化课。等过几天训练时间应该会多一点。</p>
<h3 id="cts2019随机立方体">[CTS2019]随机立方体</h3>
<p>这道题现在做了一遍好像有一点sibo啊，可能是考试的时候太紧张了吧。</p>
<p>题意就不写了。</p>
<p>题目要求恰好<span
class="math inline">k</span>个，那我们考虑用至少含<span
class="math inline">i</span>个进行容斥。</p>
<p>那么容斥系数<span class="math inline">f_i</span>需要满足：</p>
<p><span class="math display">
[i=k]=\sum_{j=0}^i{i\choose j}f_j
</span></p>
<p>进行二项式反演，得到：</p>
<p><span class="math display">
f_i=\sum_{j=0}^i(-1)^{i-j}{i\choose j}[j=k]
</span></p>
<p>即：</p>
<p><span class="math display">
f_i=(-1)^{i-k}{i\choose k}
</span></p>
<p>由于在<span class="math inline">i&lt;k</span>时<span
class="math inline">{i\choose k}</span>等于<span
class="math inline">0</span>，因此上面的式子是良定义的。</p>
<p>那么考虑如何计算至少含<span
class="math inline">i</span>个极大数的概率。</p>
<p>首先极大数的行号、列号、bule号（bule代表第三维的名称）一定不是相同的。</p>
<p>比较关键的一点是，我们可以注意到任何钦点<span
class="math inline">i</span>个两两坐标全不同的格子为极大数的概率都是相同的。于是我们可以找一个比较特殊的位置计数，比如让他们的坐标为<span
class="math inline">(1,1,1)</span>，<span
class="math inline">(2,2,2)</span>，<span
class="math inline">\dots</span>，<span
class="math inline">(i,i,i)</span>。同时我们钦点<span
class="math inline">a_{1,1,1}&lt;a_{2,2,2}&lt;\dots&lt;a_{i,i,i}</span>。</p>
<p>思考一下，可以发现如果我们只观察至少有一维横坐标<span
class="math inline">\leq i</span>的格子，<span
class="math inline">(i,i,i)</span>一定是其中的最大值。如果我们只观察至少有一维横坐标<span
class="math inline">\leq i-1</span>的格子，<span
class="math inline">(i-1,i-1,i-1)</span>一定是其中的最大值。以此类推即可。不难发现只要满足上述条件，那么这个方案一定合法。</p>
<p>我们设<span
class="math inline">a_i</span>表示所有横坐标至少有一维<span
class="math inline">\leq
i</span>的格子数。那么满足之前所述条件的概率就是：</p>
<p><span class="math display">
\prod_{j=1}^i\frac{1}{a_j}
</span></p>
<p>同时还要注意，这只是我们钦点的位置和大小关系之后的答案，所有合法的选取位置和大小关系的方案共有<span
class="math inline">{n\choose i}{m\choose i}{l\choose
i}*(i!)^3</span>种，其组合意义是分别选出三维的横、纵、bule坐标，再决定大小关系。</p>
<p>后面的方案数可以用预处理阶乘及逆元实现<span
class="math inline">O(1)</span>计算，之前的概率，则可以通过线性求逆元均摊<span
class="math inline">O(1)</span>计算。于是做一组数据就是<span
class="math inline">O(n)</span>的，总复杂度<span
class="math inline">O(Tn)</span>。</p>
<h3 id="cts2019珍珠">[CTS2019]珍珠</h3>
<p><span class="math display">
F(x)=\sum_{i\geq 0}\frac{[i\bmod
2=1]}{i!}x^i=\sinh(x)=\frac{e^x-e^{-x}}{2}
</span></p>
<p><span class="math display">
G(x)=\sum_{i\geq 0}\frac{[i\bmod
2=0]}{i!}x^i=\cosh(x)=\frac{e^x+e^{-x}}{2}
</span></p>
<p><span class="math display">
Ans=\sum_{k=0}^{n-2m}{D\choose k}n![x^n]F^kG^{D-k}
</span></p>
<p>用二项式定理把<span class="math inline">F^k</span>和<span
class="math inline">G^{D-k}</span>展开，可以得到：</p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^k\sum_{j=0}^{D-k}{D\choose
k}(-1)^{k-i}{k\choose i}{D-k\choose j}(2(i+j)-D)^n
</span></p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^k\sum_{j=0}^{D-k}\frac{D!(-1)^{k-i}(2(i+j)-D)^n}{(k-i)!i!(D-k-j)!j!}
</span></p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^k\sum_{j=0}^{D-k}\frac{(2(i+j)-D)^nD!}{(i+j)!(D-(i+j))!}*\frac{(i+j)!}{i!j!}*\frac{(-1)^{k-i}(D-(i+j))!}{(k-i)!(D-k-j)!}
</span></p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^k\sum_{j=0}^{D-k}(2(i+j)-D)^n{D\choose
i+j}{i+j\choose i}(-1)^{k-i}{D-(i+j)\choose k-i}
</span></p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i+j=0}^{D}(2(i+j)-D)^n{D\choose
i+j}\sum_{i=0}^k{i+j\choose i}(-1)^{k-i}{D-(i+j)\choose k-i}
</span></p>
<p>考虑<span class="math inline">[x^i](1+x)^n={n\choose i}</span>，<span
class="math inline">[x^i](1-x)^n=(-1)^i{n\choose i}</span>。</p>
<p>因此 <span class="math display">
{i+j\choose i}=[x^i](1+x)^{i+j},(-1)^{k-i}{D-(i+j)\choose
k-i}=[x^{k-i}](1-x)^{D-(i+j)}
</span></p>
<p><span class="math display">
\sum_{i=0}^k{i+j\choose i}(-1)^{k-i}{D-(i+j)\choose
k-i}=\sum_{i=0}^k\Big([x^i](1+x)^{i+j}\Big)*\Big([x^{k-i}](1-x)^{D-(i+j)}\Big)=[x^k](1+x)^{i+j}(1-x)^{D-(i+j)}
</span></p>
<p><span class="math display">
Ans=\frac{1}{2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^{D}(2i-D)^n{D\choose
i}[x^k](1+x)^i(1-x)^{D-i}
</span> 设<span class="math inline">a_i=\frac{(2i-D)^n{D\choose
i}}{2^D}</span>， <span class="math display">
Ans=\sum_{k=0}^{n-2m}\sum_{i=0}^{D}a_i[x^k](1+x)^i(1-x)^{D-i}
</span></p>
<p><span class="math display">
Ans=\sum_{k=0}^{n-2m}[x^k]\Big(\sum_{i=0}^{D}a_i(1+x)^i(1-x)^{D-i}\Big)
</span> 考虑先把<span
class="math inline">\sum_{i=0}^Da_i(1+x)^i(1-x)^{D-i}</span>算出来，最后一个个加。</p>
<p>至于这个，可以使用分治fft大法。</p>
<p><del>什么一个log，分治fft天下第一。</del></p>
<h3 id="cts2019氪金手游">[CTS2019]氪金手游</h3>
<p>现在想想怎么又比较简单啊。</p>
<p>考虑把关系树随便钦点一个当根。</p>
<p>由于正向边（向儿子连的边，表示必须早于儿子）和反向边同时存在，因此比较麻烦。考虑用容斥将反向边变为正向边，即：选出一个反向边子集<span
class="math inline">S</span>，强制这些边必须被违反，其余反向边随意。注意正向边是永远需要满足的。计算得这样计算出的方案有<span
class="math inline">(-1)^{|S|}</span>的贡献。</p>
<p>对于一种选法，原树用正向边分成了若干联通块。对于一个点<span
class="math inline">i</span>，设<span
class="math inline">s_i</span>表示是它的子树中的点的集合。如果只考虑这棵子树，我们显然要满足<span
class="math inline">i</span>是第一个被抽出来的，概率就是<span
class="math inline">\frac{w_i}{\sum_{j\in
s_i}w_j}</span>，接下来可以分成若干子树递归。</p>
<p>那么若干种方案就可以合起来算概率了。我们设<span
class="math inline">dp_{i,j}</span>表示以<span
class="math inline">i</span>为根的子树，当<span
class="math inline">(\sum_{k\in
s_i}w_k)=j</span>时，目前满足所有条件的情况乘以他们的系数的概率和。转移比较容易得到。</p>
<h3 id="zjoi2019开关">[ZJOI2019]开关</h3>
<p>这真是一道好题，被送退役得心服口服。</p>
<p>先说几个结论：</p>
<p>我们设<span class="math inline">\tilde f</span>表示集合幂级数<span
class="math inline">f</span>在快速沃尔什变换(<span
class="math inline">\text{FWT}</span>)后的形式。</p>
<p>那么： <span class="math display">
[x^S]\tilde f=\sum_{T}(-1)^{|S\cap T|}[x^T]f
</span> 从<span class="math inline">\text{FWT}</span>的意义中可以看出。
<span class="math display">
\sum_{T}(-1)^{|S\cap T|}=2^n[S=\emptyset]
</span> 其中<span
class="math inline">n</span>代表全集的大小。这和子集容斥的原理是相似的。
<span class="math display">
\sum_{T}[x^T]\tilde f=2^n[x^{\emptyset}]f
</span> 用前一个式子不难证明。</p>
<p>现在说题目的解法。</p>
<p>根据题目描述，我们设<span
class="math inline">[x^S]f</span>表示第一次到达状态<span
class="math inline">S</span>的期望步数。为了分析方便，我们也可以将其看成是从状态<span
class="math inline">S</span>到空集的期望步数。那么对于<span
class="math inline">S\neq \emptyset</span>，我们就有： <span
class="math display">
[x^S]f=\Big(\sum_i\frac{p_i}{\sum_j p_j}[x^{S\Delta\{i\}}]f\Big)+1
</span> 为了更方便的表达这个式子，我们设形式幂级数<span
class="math inline">g</span>，其中当<span
class="math inline">S=\{i\}</span>时，<span
class="math inline">[x^S]g=\frac{p_i}{\sum_j p_j}</span>，否则<span
class="math inline">[x^S]g=0</span>。</p>
<p>于是上式可以表达为： <span class="math display">
f=\Big(\sum_{T}x^T\Big)+fg+cx^{\emptyset}
</span> 其中<span
class="math inline">c</span>是某个不确定的系数，起到补偿<span
class="math inline">\emptyset</span>不符合该式的作用。我们尝试进行<span
class="math inline">\text{FWT}</span>，对于<span
class="math inline">\sum_{T}x^T</span>，它是<span
class="math inline">x^{\emptyset}</span>进行<span
class="math inline">\text{FWT}</span>后的结果，因此其<span
class="math inline">\text{FWT}^{-1}</span>的结果为<span
class="math inline">x^{\emptyset}</span>，所以其<span
class="math inline">\text{FWT}</span>后的结果为<span
class="math inline">2^nx^\emptyset</span>。因此： <span
class="math display">
[x^S]\tilde f=2^n[S=\emptyset]+[x^S]\tilde f[x^S]\tilde g+c
</span></p>
<p><span class="math display">
(1-[x^S]\tilde g)[x^S]\tilde f=2^n[S=\emptyset]+c
</span> 考虑<span class="math inline">[x^\emptyset]\tilde
g=\sum_{i}\frac{p_i}{\sum_j p_j}=1</span>，因此将<span
class="math inline">S=\emptyset</span>代入上式可得<span
class="math inline">c=-2^n</span>。</p>
<p>那么对于<span class="math inline">S\neq \emptyset</span>，就有：
<span class="math display">
[x^S]\tilde f=-\frac{2^n}{1-[x^S]\tilde g}
</span> 代入<span
class="math inline">\text{FWT}^{-1}</span>的式子中，我们就有： <span
class="math display">
[x^S]f=\frac{1}{2^n}\Big(\sum_{T}(-1)^{|S\cap T|}[x^T]\tilde
f\Big)=\frac{[x^\emptyset]\tilde f}{2^n}-\Big(\sum_{T\neq
\emptyset}(-1)^{|S\cap T|}\frac{1}{1-[x^T]\tilde g}\Big)
</span> 而由于<span
class="math inline">[x^\emptyset]f=0</span>，根据之前的结论，<span
class="math inline">\sum_T[x^T]\tilde f=0</span>，所以<span
class="math inline">[x^\emptyset]\tilde f=-\Big(\sum_{T\neq
\emptyset}[x^T]\tilde f\Big)=\sum_{T\neq
\emptyset}\frac{2^n}{1-[x^T]\tilde g}</span></p>
<p>因此： <span class="math display">
[x^S]f=\frac{1}{2^n}\Big(\sum_{T}(-1)^{|S\cap T|}[x^T]\tilde
f\Big)=\Big(\sum_{T\neq \emptyset}\frac{1}{1-[x^T]\tilde
g}\Big)-\Big(\sum_{T\neq \emptyset}(-1)^{|S\cap
T|}\frac{1}{1-[x^T]\tilde g}\Big)
</span></p>
<p><span class="math display">
[x^S]f=\sum_{T\neq \emptyset}[|S\cap T|\equiv1(\bmod \
2)]\frac{2}{1-[x^T]\tilde g}
</span> 代入<span class="math inline">[x^T]\tilde g=\sum_{i}(-1)^{[i\in
T]}\frac{p_i}{\sum_j p_j}</span>，得<span
class="math inline">1-[x^T]\tilde g=\sum_{i}[i\in
T]\frac{2p_i}{\sum_{j}p_j}</span>，回代入原式，得： <span
class="math display">
[x^S]f=\sum_{T\neq \emptyset}[|S\cap T|\equiv1(\bmod \
2)]\frac{\sum_{j}p_j}{\sum_{i\in T}p_i}
</span></p>
<p><span class="math display">
[x^S]f=\Big(\sum_j p_j\Big)*\Big(\sum_{T\neq \emptyset}[|S\cap
T|\equiv1(\bmod \ 2)]\frac{1}{\sum_{i\in T}p_i}\Big)
</span> 由于<span class="math inline">\sum_j
p_j</span>非常小，因此后面的式子可以通过简单的<span
class="math inline">dp</span>计算出来。</p>
<h3 id="zjoi2019语言">[ZJOI2019]语言</h3>
<p>考场上只会写3个<span class="math inline">\log</span>的我太菜了。</p>
<p>考虑对于一个点，它能交流的所有点就是经过它的链的并。</p>
<p>我们可以用线段树来维护一个点集的连通并的点数（即最小的使得某些点都在内的连通块的点数），具体做法不讲了（想必这篇博客没有人看的233，如果有人问再加上去吧）。再用树上差分思想，在点上添加事件，加上线段树合并，就做完了。</p>
<p>虽然是一个<span
class="math inline">\log</span>的但我写出来跑的有点慢，可能我太菜了。</p>
<h3 id="loj-575-不等关系">LOJ #575 不等关系</h3>
<p>一道不算很难的容斥题。</p>
<p>考虑最简单的容斥方法，用<span
class="math inline">至少违背零个大于号-至少违背一个大于号+至少违背两个大于号\dots</span>来计算，对于至少违背<span
class="math inline">k</span>个大于号的方案数，可以发现当我们选定了哪些位置违背以后，限制就只剩下小于号了。此时长度为<span
class="math inline">n+1</span>的排列会被分成<span
class="math inline">m</span>部分，大小分别为<span
class="math inline">a_1,a_2,\dots,a_m</span>，每一段内要满足大小递增。那么此时的答案就是：
<span class="math display">
{n+1\choose a_1,a_2,\dots,a_m}=\frac{(n+1)!}{\prod_{i=1}^ma_i!}
</span> <span
class="math inline">(n+1)!</span>对于所有方案都是相同的，我们可以不管它。于是只要将所有段的大小的阶乘的逆元相乘就是方案数。</p>
<p>首先考虑暴力做法，我们根据字符串<span
class="math inline">s</span>先将排列划分为<span
class="math inline">m</span>段，大小分别为<span
class="math inline">a_1,a_2,\dots,a_m</span>（这和上面的定义不一样，只是我懒得换字母了），由于容斥的关系，一些段可能会并起来。我们假定违背了其中<span
class="math inline">k</span>个大于号，合并后段的大小分别为<span
class="math inline">b_1,b_2,\dots,b_{m-k}</span>，那么这种方案的贡献为<span
class="math inline">(-1)^k\Big(\prod_{i=1}^{m-k}\frac{1}{b_i!}\Big)</span>。</p>
<p>那么考虑<span class="math inline">dp</span>，我们设<span
class="math inline">f_i</span>表示只考虑前<span
class="math inline">i</span>段，所有方案的贡献和。设<span
class="math inline">S_i</span>表示<span
class="math inline">a</span>的前<span
class="math inline">i</span>项和。那么我们只要枚举第<span
class="math inline">i</span>段会与前面的几段合并，就可以得出方程： <span
class="math display">
f_i=\sum_{j=0}^{i-1}(-1)^{i-j+1}f_j\frac{1}{\Big(S_i-S_j\Big)!}
</span> 就得到了<span class="math inline">O(n^2)</span>的做法。</p>
<p>可以注意到，由于和式中的最后一项非常复杂，因此很难优化成卷积形式。我们考虑更换一种方法，改设<span
class="math inline">f_i</span>表示只考虑排列的前<span
class="math inline">i</span>个，所有方案的贡献和。值得注意的是如果<span
class="math inline">i</span>和<span
class="math inline">i+1</span>之间是小于，即原本在一段内的，那么我们可以任意取<span
class="math inline">f_i</span>的值，因为我们将看到它对后面是没有影响的。我们再设<span
class="math inline">a_i</span>表示<span
class="math inline">i</span>和<span
class="math inline">i+1</span>之间是否用大于号连接（即可以断开），特别的，<span
class="math inline">a_0=a_{n+1}=1</span>。设<span
class="math inline">S_i</span>表示<span
class="math inline">a</span>的前<span
class="math inline">i</span>项和。</p>
<p>根据之前的思路，易得： <span class="math display">
f_i=\sum_{j=0}^{i-1}(-1)^{S_i-S_j+1}a_jf_j\frac{1}{(i-j)!}
</span> 变化一下，得： <span class="math display">
(-1)^{S_i}f_i=\sum_{j=0}^{i-1}\Big(a_j(-1)^{S_j}f_j\Big)*\Big(-\frac{1}{(i-j)!}\Big)
</span></p>
<p>可以发现，虽然其转化为简单的卷积式比较困难，但是借助分治fft，我们就可以先将<span
class="math inline">(-1)^{S_i}f_i</span>算出来，再乘上<span
class="math inline">a_i</span>贡献给后面了。复杂度<span
class="math inline">O(n\log^2 n)</span>。</p>
<p>所以说，分治fft天下第一。</p>
</body>
</html>
