<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>b</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><del>鸽子更博了！</del></p>
<p>如今大学已尘埃落定，终于成功进入清华，不过不在计算机系。还是希望将<span
class="math inline">OI</span>作为一种爱好，也想找机会参加<span
class="math inline">acm</span>，因此还是会时不时复健一下。这一题是我记忆中攻克最艰难、解题后也最痛快的一题，因此印象深刻。当然我早已忘了具体的步骤，因此最近重做了一遍，也算是对自己的魔鬼训练吧。</p>
<blockquote>
<p>与群论相关的前置知识： 设<span
class="math inline">G</span>是所有长度为<span
class="math inline">n</span>的置换构成的群，<span
class="math inline">X</span>是一些长度为<span
class="math inline">n</span>的序列构成的集合。如果将<span
class="math inline">G</span>作用于<span
class="math inline">X</span>，那么： 对于<span class="math inline">x\in
X</span>，称<span class="math inline">\{y\in X|y=f(x),f\in
G\}</span>为<span class="math inline">x</span>的轨道，记为<span
class="math inline">Orbit(x)</span>，对于<span class="math inline">y\in
Orbit(x)</span>，称<span class="math inline">y</span>为<span
class="math inline">x</span>的等价类。 对于<span
class="math inline">x\in X</span>，称<span class="math inline">\{f\in
G|x=f(x)\}</span>为<span
class="math inline">x</span>的稳定化子，记为<span
class="math inline">SG(x)</span>。 对于<span class="math inline">f\in
G</span>，称<span class="math inline">\{x\in X|x=f(x)\}</span>为<span
class="math inline">f</span>的不动点，记为<span
class="math inline">fix(f)</span>。</p>
</blockquote>
<p>与题意类似，我们定义两个森林同构，当且仅当可以通过某种一一对应关系，使得一个森林的任意一棵树都和另一森林对应的树同构。</p>
<p>设<span class="math inline">cnt_n</span>为<span
class="math inline">n</span>个点的无标号有根树个数，并令所有树从<span
class="math inline">1</span>到<span
class="math inline">cnt_n</span>标号。</p>
<p>那么令<span
class="math inline">S_{n,i}</span>表示所有按照题目要求构造的带标号有根树中，与<span
class="math inline">n</span>个点的<span
class="math inline">i</span>号无标号有根树同构的那一部分构成的集合。</p>
<p>由于按照题意建立的<span class="math inline">n</span>个点的树共有<span
class="math inline">(n-1)!</span>种，因此 <span class="math display">
ans=\frac{1}{(n-1)!^k}\sum_{i=1}^{cnt_n}|S_{n,i}|^k
</span> 那么重点关注后半部分，尝试利用动态规划的方法解题。那么令： <span
class="math display">
dp_n=\sum_{i=1}^{cnt_n}|S_{n,i}|^k
</span>
考虑如何转移。回想判断无标号有根树同构的过程：先将根的所有子树按照一定规则排序，逐一比较即可。那么是否可以先枚举排序后在最后的子树，将其删去递归求解，再考虑这棵子树的贡献呢？</p>
<p>但是，如果枚举排在最后的子树，那么就隐含了条件：对于递归的树，其根的所有子树的优先级一定在该子树之前（或者就是该子树），而子树的数目众多，无法比较好的设计状态。</p>
<p>但这样的思考并不是毫无意义的。虽然枚举最后的子树不太现实，但也许可以退而求其次，对子树先进行一个“粗略的划分”，而非直接一个个分离。不难想到先根据子树大小从小到大初步排序，每次删去大小最大的那一批子树，对剩余的树进行递归求解，再考虑这些相同大小的子树的贡献。那么对递归求解的树的额外要求，就转变为了根的子树大小不能超过某个值，不仅状态大量减少，考虑起来也非常方便。</p>
<p>那么为了方便，我们记<span
class="math inline">mxs(S_{n,i})</span>表示对于集合<span
class="math inline">S_{n,i}</span>中的树，他们根的子树的最大大小，类似记<span
class="math inline">mns(S_{n,i})</span>表示最小的。根据上面的想法，可以设计辅助状态：
<span class="math display">
tmp_{n,p}=\sum_{i=1}^{cnt_n}[mxs(S_{n,i})\leq p]|S_{n,i}|^k
</span> 则有<span
class="math inline">dp_n=tmp_{n,n-1}</span>。再考虑状态的转移。那么就枚举大小为<span
class="math inline">p</span>的根的子树的数目，分配标号，再将前后部分独立考虑。前半部分可以递归到之前的状态，但后半部分无法递归，需要单独解决，表示成式子，就是：
<span class="math display">
tmp_{n,p}=\sum_{u=0}^{\lfloor\frac{n-1}{p}\rfloor}{n-1\choose
u*p}^ktmp_{n-u*p,p-1}*f_{p,u}
</span> 因为<span
class="math inline">1</span>号点显然是根，所以实际分配的标号只有<span
class="math inline">n-1</span>个。其中： <span class="math display">
f_{p,u}=\sum_{i=1}^{cnt_{u*p+1}}[mns(S_{u*p+1,i})=mxs(S_{u*p+1,i})=p]|S_{u*p+1,i}|^k
</span> 表示需要单独解决的那一部分。之所以大小为<span
class="math inline">u*p+1</span>，是因为我们给着<span
class="math inline">u</span>棵大小为<span
class="math inline">p</span>的树额外加了一个形式上的根，方便考虑问题。那么第一步先考虑标号的分配。</p>
<p>按照常规来讲，标号的分配应该是<span class="math inline">{u*p\choose
p,p,\dots,p}</span>种情况，但在此处，由于根的所有子树之间是没有顺序的（这也是之前进行“粗略的划分”遗留下来的问题），因此如果出现两棵相同的子树，它们的地位完全等价，也即即使赋予它们的标号互换，得到的也是同一种结果。但是<span
class="math inline">{u*p\choose
p,p,\dots,p}</span>的分配方式显然将互换前后看作不一样的。</p>
<p>看来<span class="math inline">{u*p\choose
p,p,\dots,p}</span>并不能适用于所有情况，还需要进行进一步的分类讨论。那么我们假设其中某一个<span
class="math inline">S_{u*p+1,i}</span>，其根的子树可以分为<span
class="math inline">m</span>类本质不同的，且数目分别为<span
class="math inline">a_1,a_2,a_3,\dots,a_m\Big((\sum_{t=1}^ma_t)=u\Big)</span>，也不妨将<span
class="math inline">a</span>不降序排序。对于同一类的子树内部，任意两棵树都可以互换标号，因此分配给这一类的<span
class="math inline">a_t</span>组标号彼此是无序的，需要将分配标号方案数乘以<span
class="math inline">\frac{1}{a_t!}</span>。因此对这一情况，分配的方法数应该为：
<span class="math display">
{u*p\choose
p,p,\dots,p}*\bigg(\prod_{t=1}^m\frac{1}{a_t!}\bigg)=\frac{(u*p)!}{(p!)^u}*\bigg(\prod_{t=1}^m\frac{1}{a_t!}\bigg)
</span> 初步解决分配标号的问题后，我们再考虑下一步操作。此时只要将<span
class="math inline">u</span>棵子树内部的标号都看作是<span
class="math inline">1,2,\dots,p</span>即可，此时可以去掉形式上的根，将其转化为<span
class="math inline">u</span>棵树的森林。根据之前的定义，我们可以将全体大小为<span
class="math inline">p</span>的无标号有根树编号为<span
class="math inline">1,2,\dots,cnt_p</span>。对于某一个森林，将其每一棵树对应到这棵树所属类别的编号，我们可以将该森林与一个无序可重集合<span
class="math inline">\widetilde x</span>对应。将所有<span
class="math inline">\widetilde x</span>组成的集合记作<span
class="math inline">\widetilde X</span>。</p>
<p>则<span class="math inline">\widetilde
x</span>满足两个性质：恰好包含<span
class="math inline">u</span>个数，且每个数都在<span
class="math inline">1</span>到<span
class="math inline">cnt_p</span>之间。也可以将<span
class="math inline">a_t</span>的概念从<span
class="math inline">S_{u*p+1,i}</span>迁移到<span
class="math inline">\widetilde x</span>上。不妨记<span
class="math inline">\omega_{\widetilde x}</span>为属于<span
class="math inline">\widetilde x</span>对应森林的带标号森林的数目的<span
class="math inline">k</span>次幂，那么<span
class="math inline">f_{p,u}</span>可以表示为： <span
class="math display">
f_{p,u}=\sum_{\widetilde x \in \widetilde
X}\frac{(u*p)!^k}{(p!)^{u*k}}*\bigg(\prod_{t=1}^m\frac{1}{a_t!^k}\bigg)*\omega_{\widetilde
x}
</span></p>
<p><span class="math display">
=\frac{(u*p)!^k}{(p!)^{u*k}}*\Bigg(\sum_{\widetilde x \in \widetilde
X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^k}\bigg)*\omega_{\widetilde
x}\Bigg)\tag{$*$}
</span> 因为在分配完标号以后，树的同构就转化为了森林的同构。</p>
<p>然而，由于<span class="math inline">\widetilde
x</span>是无序可重集合，这非常不利于枚举，因此直接进行计算也非常麻烦。希望能将其转化为有序可重集合（即一个长度为<span
class="math inline">u</span>的序列）再进一步解决问题。</p>
<p>那么设<span class="math inline">x</span>是一个长度为<span
class="math inline">u</span>的序列，且每一个数都在<span
class="math inline">1</span>到<span
class="math inline">cnt_p</span>之间。将所有这样的<span
class="math inline">x</span>的集合记做<span
class="math inline">X</span>。如果<span
class="math inline">x</span>无序化后能和某一个<span
class="math inline">\widetilde x</span>相同，我们称<span
class="math inline">x</span>对应到<span class="math inline">\widetilde
x</span>。</p>
<p>由于<span class="math inline">\widetilde
x</span>是一个可重的集合，因此对应到<span class="math inline">\widetilde
x</span>的<span
class="math inline">x</span>的数目是变化的，不能直接枚举<span
class="math inline">x</span>。想要利用<span
class="math inline">X</span>得到一个和<span
class="math inline">(*)</span>相类似的等式，还需要借助置换群。</p>
<p>为了表达方便，用前置知识中的术语来表达。设<span
class="math inline">G</span>是所有长度为<span
class="math inline">u</span>的置换构成的群，将<span
class="math inline">G</span>作用于<span
class="math inline">X</span>。</p>
<p>那么对于一个<span
class="math inline">Orbit(x)</span>，所有在这一集合内的<span
class="math inline">y</span>都对应到相同的<span
class="math inline">\widetilde x</span>，可以用<span
class="math inline">Orbit(x)</span>来代替<span
class="math inline">\widetilde x</span>。将<span
class="math inline">a_t</span>、<span
class="math inline">\omega</span>的概念迁移到<span
class="math inline">x</span>上，我们可以得到与<span
class="math inline">(*)</span>类似的式子： <span class="math display">
f_{p,u}=\frac{(u*p)!^k}{(p!)^{u*k}}*\Bigg(\sum_{x\in
X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^k}\bigg)*\frac{\omega
_x}{|Orbit(x)|}\Bigg)
</span> 不难发现<span
class="math inline">|Orbit(x)|=\frac{u!}{\prod_{t=1}^ma_t!}</span>。此时有一个难点，就是<span
class="math inline">\omega_x</span>的计算。先尝试将所有<span
class="math inline">a</span>相同的<span
class="math inline">x</span>发在一起计算（此时<span
class="math inline">\bigg(\prod_{t=1}^m\frac{1}{a_t!^k}\bigg)</span>和<span
class="math inline">|Orbit(x)|</span>是相同的）。也就是说，此时的森林要求有<span
class="math inline">m</span>种不同的树，第<span
class="math inline">i</span>种<span
class="math inline">a_i</span>棵。首先考虑<span
class="math inline">m=1</span>的情况，也就是需要<span
class="math inline">u</span>棵同构的树，不难发现这就等同于： <span
class="math display">
\sum_{i=1}^{cnt_p}\Big(|S_{p,i}|^u\Big)^k=\sum_{i=1}^{cnt_p}|S_{p,i}|^{u*k}
</span>
看上去似乎并未计算过这个式子，为了计算可能需要修改状态。那么先搁置一边，考虑<span
class="math inline">m&gt;1</span>的情况，我们能否直接用下面的式子：
<span class="math display">
\prod_{t=1}^m\Bigg(\sum_{i=1}^{cnt_p}|S_{p,i}|^{a_t*k}\Bigg)\tag{$**$}
</span>
计算呢？不可行，因为这并不能排除不同的两组得到同一类树的情况，同时也没有考虑组与组的数目相同时地位等价的问题。</p>
<p>但这样的思考并不是毫无意义的。不难发现，如果组与组之间默认为地位不等，且不同的组可以使用相同的一类树，那么<span
class="math inline">(**)</span>就是正确的。</p>
<p>最关键的一点是，这两个条件似乎与某一置换下的不动点有异曲同工之妙。我们考虑<span
class="math inline">f\in G</span>，则<span
class="math inline">fix(f)</span>就是<span
class="math inline">f</span>的不动点集合。<span
class="math inline">f</span>是由若干个置换环组成的，设有<span
class="math inline">m&#39;</span>个置换环，并设置换环的大小分别为<span
class="math inline">a&#39;_1,a&#39;_2,\dots,a&#39;_{m&#39;}</span>。可以发现，如果<span
class="math inline">x</span>是<span
class="math inline">f</span>的不动点，那么有与之前的<span
class="math inline">a</span>类似的性质，同一置换环内的位置上，树的种类必须相同。但是，由于置换环本身位置不同，每个置换环就是地位不等的（这也是有序序列的一个好处）。并且，由于我们只要求其为不动点即可，并不需要每个置换环的树种类各不相同，这就完美的符合我们之前的两个条件。</p>
<p>因此我们就可以利用<span class="math inline">(**)</span>了，也就是说：
<span class="math display">
\sum_{x\in
fix(f)}\omega_x=\prod_{t=1}^{m&#39;}\Bigg(\sum_{i=1}^{cnt_p}|S_{p,i}|^{a&#39;_t*k}\Bigg)
</span> 不过还有一个问题没有解决：怎么求<span
class="math inline">\sum_{i=1}^{cnt_p}|S_{p,i}|^{a&#39;_t*k}</span>？它的形式和<span
class="math inline">dp_p</span>相似，但是指数增加了<span
class="math inline">a&#39;_t</span>倍。必须先进一步扩张状态才能解决这个问题。</p>
<p>那么增加一个指标<span
class="math inline">j</span>，表示指标扩张的倍数。即： <span
class="math display">
dp_{n,j}=\sum_{i=1}^{cnt_n}|S_{n,i}|^{j*k}
</span></p>
<p><span class="math display">
tmp_{n,j,p}=\sum_{i=1}^{cnt_n}[mxs(S_{n,i})\leq p]|S_{n,i}|^{j*k}
</span></p>
<p><span class="math display">
f_{p,j,u}=\sum_{i=1}^{cnt_{u*p+1}}[mns(S_{u*p+1,i})=mxs(S_{u*p+1,i})=p]|S_{u*p+1,i}|^{j*k}
</span> 相应修改转移方程： <span class="math display">
tmp_{n,j,p}=\sum_{u=0}^{\lfloor\frac{n-1}{p}\rfloor}{n-1\choose
u*p}^{j*k}tmp_{n-u*p,j,p-1}*f_{p,j,u}
</span></p>
<p><span class="math display">
f_{p,j,u}=\frac{(u*p)!^{j*k}}{(p!)^{u*j*k}}*\Bigg(\sum_{x\in
X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\bigg)*\frac{\omega
_x}{|Orbit(x)|}\Bigg)
</span> 则： <span class="math display">
\sum_{x\in
fix(f)}\omega_x=\prod_{t=1}^{m&#39;}\Bigg(\sum_{i=1}^{cnt_p}|S_{p,i}|^{a&#39;_t*j*k}\Bigg)=\prod_{t=1}^{m&#39;}dp_{p,a&#39;_t*j}
</span> 注意<span class="math inline">\omega_x</span>也是和<span
class="math inline">j</span>相关的。</p>
<p>首先考虑一下状态数量问题，可以发现由于<span
class="math inline">a&#39;_t\leq
\frac{n}{p}</span>，因此这两维的乘积不会超过全局的<span
class="math inline">n</span>，因此只有<span
class="math inline">\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor=O(n\log
n)</span>种可能。</p>
<p>还有一个问题是，我们并不只是简单的求<span
class="math inline">\sum_{x\in X}\omega_x</span>，而是有一个<span
class="math inline">\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{1}{|Orbit(x)|}</span>的系数，不能这样直接交换求和顺序。</p>
<p>那要通过什么方式转化呢？我们设置换<span
class="math inline">f</span>的某个权值为<span
class="math inline">w_f</span>，那么有如下等式： <span
class="math display">
\sum_{x\in X}\omega_x\Big(\sum_{f\in SG(x)}w_f\Big)=\sum_{f\in
G}w_f\Big(\sum_{x\in fix(f)}\omega_x\Big)
</span> 只是交换了求和顺序，显然成立。这个等式的左边和<span
class="math inline">\sum_{x\in
X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\bigg)*\frac{\omega
_x}{|Orbit(x)|}</span>相似，右边和<span class="math inline">\sum_{x\in
fix(f)}\omega_x</span>相似，尝试利用这个等式来对目标进行转化。</p>
<p>如果能找到某种权重函数<span class="math inline">w</span>，使得等式：
<span class="math display">
\sum_{f\in
SG(x)}w_f=C*\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{1}{|Orbit(x)|}
</span> 成立，其中<span
class="math inline">C</span>是一个常数，那么就有： <span
class="math display">
\sum_{x\in X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\bigg)*\frac{\omega
_x}{|Orbit(x)|}=\frac{1}{C}\sum_{x\in X}\omega_x\bigg(\sum_{f\in
SG(x)}w_f\bigg)
</span></p>
<p><span class="math display">
=\frac{1}{C}\sum_{f\in G}w_f\bigg(\sum_{x\in fix(f)}\omega_x\bigg)
</span></p>
<p><span class="math display">
=\frac{1}{C}\sum_{f\in
G}w_f\bigg(\prod_{t=1}^{m&#39;}dp_{p,a&#39;_t*j}\bigg)\tag{$***$}
</span>
由于后方的连乘只和置换环大小情况有关，那么自然也希望权重函数也之和置换环大小有关，而且最好也是连乘形式，即：
<span class="math display">
w_f=\prod_{t=1}^{m&#39;}{\widetilde w}_{a&#39;_t}
</span> 如果可行，那么可以继续转化<span
class="math inline">(***)</span>式： <span class="math display">
=\frac{1}{C}\sum_{f\in G}\bigg(\prod_{t=1}^{m&#39;}{\widetilde
w}_{a&#39;_t}\bigg)*\bigg(\prod_{t=1}^{m&#39;}dp_{p,a&#39;_t*j}\bigg)
</span></p>
<p><span class="math display">
=\frac{1}{C}\sum_{f\in G}\bigg(\prod_{t=1}^{m&#39;}{\widetilde
w}_{a&#39;_t}*dp_{p,a&#39;_t*j}\bigg)
</span>
则每个置换的结果都只和其置换环分解的大小分布情况有关，可以换一种求和方式，令<span
class="math inline">h_i={\widetilde
w}_{i}*dp_{p,i*j}</span>，枚举置换环的大小分布，并分配标号： <span
class="math display">
=\frac{1}{C}\sum_{f\in G}\bigg(\prod_{t=1}^{m&#39;}h_{a&#39;_t}\bigg)
</span></p>
<p><span class="math display">
=\frac{1}{C}\sum_{l&gt;0}\frac{1}{l!}\Bigg(\sum_{\sum_{t=1}^lb_t=u}{u\choose
b_1,b_2,\dots,b_l}\bigg(\prod_{t=1}^l
(b_t-1)!\bigg)\bigg(\prod_{t=1}^{l}h_{b_t}\bigg)\Bigg)
</span></p>
<p><span class="math display">
=\frac{u!}{C}\sum_{l&gt;0}\frac{1}{l!}\Bigg(\sum_{\sum_{t=1}^lb_t=u}\bigg(\prod_{t=1}^{l}\frac{h_{b_t}}{b_t}\bigg)\Bigg)
</span> 似乎转化为了熟悉的式子。设生成函数<span
class="math inline">H(x)=\sum_{i&gt;0}\frac{h_i}{i}x^i</span>，那么前面的式子就转化为：
<span class="math display">
=\frac{u!}{C}\sum_{l&gt;0}\frac{1}{l!}\Bigg(\sum_{\sum_{t=1}^lb_t=u}\bigg(\prod_{t=1}^{l}[x^{b_t}]H(x)\bigg)\Bigg)
</span></p>
<p><span class="math display">
=\frac{u!}{C}\sum_{l&gt;0}\frac{[x^u]H^l(x)}{l!}
</span></p>
<p><span class="math display">
=\frac{u!}{C}[x^u]e^{H(x)}
</span> 好的！也就是说，我们现在有： <span class="math display">
f_{p,j,u}=\frac{(u*p)!^{j*k}}{(p!)^{u*j*k}}*\Bigg(\sum_{x\in
X}\bigg(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\bigg)*\frac{\omega
_x}{|Orbit(x)|}\Bigg)
</span></p>
<p><span class="math display">
=\frac{(u*p)!^{j*k}}{(p!)^{u*j*k}}*\frac{u!}{C}[x^u]e^{H(x)}
</span> 唯一的问题就是计算权重函数<span class="math inline">\widetilde
w</span>了。回顾一下，我们是希望满足这个等式： <span
class="math display">
\sum_{f\in SG(x)}w_f=\sum_{f\in SG(x)}\bigg(\prod_{t=1}^m{\widetilde
w}_{a_t}\bigg)=C*\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{1}{|Orbit(x)|}
</span> 展开<span class="math inline">|Orbit(x)|</span>，即： <span
class="math display">
\sum_{f\in SG(x)}\bigg(\prod_{t=1}^m{\widetilde
w}_{a_t}\bigg)=C*\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{\prod_{t=1}^ma_t!}{u!}
</span> 对于<span
class="math inline">x</span>，它的稳定化子就是满足仅在相同种类树之间进行置换的集合，就是说，只能在同种树内部进行置换环的拆解。那么模仿之前对置换环的枚举方法，换一种方式计算等式左边的值，只是换成了在每一类树内部：
<span class="math display">
=\prod_{t=1}^{m}\Bigg(\sum_{l&gt;0}\frac{1}{l!}\bigg(\sum_{\sum_{t&#39;=1}^lb_{t&#39;}=a_t}{a_t\choose
b_1,b_2,\dots,b_l}*\bigg(\prod_{t&#39;=1}^{l}(b_{t&#39;}-1)!\bigg)*\bigg(\prod_{t&#39;=1}^{l}{\widetilde
w_{b_{t&#39;}}}\bigg)\bigg)\Bigg)
</span></p>
<p><span class="math display">
=\prod_{t=1}^{m}a_t!*\Bigg(\sum_{l&gt;0}\frac{1}{l!}\bigg(\sum_{\sum_{t&#39;=1}^lb_{t&#39;}=a_t}\bigg(\prod_{t&#39;=1}^{l}\frac{{\widetilde
w_{b_{t&#39;}}}}{b_{t&#39;}}\bigg)\bigg)\Bigg)
</span> 同之前，设<span
class="math inline">W(x)=\sum_{i&gt;0}\frac{{\widetilde
w}_i}{i}x^i</span>，那么上方等式继续转化： <span class="math display">
=\prod_{t=1}^{m}a_t!*[x^{a_t}]e^{W(x)}
</span> 带回原等式，即为： <span class="math display">
\prod_{t=1}^{m}a_t!*[x^{a_t}]e^{W(x)}=C*\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{\prod_{t=1}^ma_t!}{u!}
</span> 消去<span class="math inline">\prod_{t=1}^{m}a_t!</span>： <span
class="math display">
\prod_{t=1}^{m}[x^{a_t}]e^{W(x)}=\Big(\prod_{t=1}^m\frac{1}{a_t!^{j*k}}\Big)*\frac{C}{u!}
</span></p>
<p>显然我们令<span class="math inline">C=u!</span>，那么有<span
class="math inline">[x^i]e^{W(x)}=\frac{1}{i!^{j*k}}</span>，<span
class="math inline">e^{W(x)}</span>就是一个已知的多项式。通过<span
class="math inline">W(x)=\ln e^{W(x)}</span>就可以求解出<span
class="math inline">\widetilde w</span>了。</p>
<p>回顾一下过程，可以计算出复杂度是<span class="math inline">O(n^2\log
n)</span>。由于多项式<span class="math inline">\ln</span>和<span
class="math inline">\exp</span>不是瓶颈，可以用简洁的<span
class="math inline">O(n^2)</span>算法来计算。</p>
</body>
</html>
