<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>所谓花，就是如下图所示的一个奇环： <img
src="https://s1.ax1x.com/2018/09/11/iF5wse.png" alt="1" /></p>
<p>本文中粗边代表现在的匹配边，细边代表该点的前驱（后文会讲解前驱是什么，现在只需要知道每个点和它的前驱在原图中一定是有边的）。</p>
<p>如图所示，一朵包含<span
class="math inline">2k+1</span>个点的花一定至多包含<span
class="math inline">k</span>条匹配边，于是总会剩下一个未匹配的点，上图中即为<span
class="math inline">1</span>号点。</p>
<p>那么我们可以发现，如果有另外一个点想要与花中的某个点<span
class="math inline">v</span>匹配，那么有两种情况：1、<span
class="math inline">v</span>是未匹配的点（即1号点），那么直接与<span
class="math inline">v</span>匹配即可。2、<span
class="math inline">v</span>是已经匹配的点，这时只要将花中的匹配状况修改，使得<span
class="math inline">v</span>变成未匹配的那个点即可。</p>
<p>综上所述，只要花中的点没有向外匹配，我们总是可以使得外部的一个点和花中任意一个点匹配，因此花的性质和点其实很相似。我们将花缩成一个点来处理，就可以解决出现奇环的问题。以上思想就是带花树算法的核心。</p>
<p>==================总之分割一下好了==================</p>
<p>带花树算法的过程其实和<span
class="math inline">bfs</span>版本的匈牙利是很相似的，都是找出一个交错树，交错树可能长这样（注意每个蓝色点可能有多个橙色儿子，但是每个橙色点只能有一个蓝色儿子）：
<img src="https://s1.ax1x.com/2018/09/12/ik0ko4.png" alt="2" /></p>
<p>其中1号点就是我们尝试增广的节点，在这里我们给每一个节点一个<span
class="math inline">type</span>值，若该点不在交错树中，它的<span
class="math inline">type</span>值为<span
class="math inline">0</span>，否则为<span
class="math inline">1</span>或<span
class="math inline">2</span>。上图中我们用蓝色点代表<span
class="math inline">type=1</span>的点，橙色点代表<span
class="math inline">type=2</span>的点，不难看出<span
class="math inline">type</span>值的不同其实代表了一种类似于二分图的关系，每个点在交错树中只和<span
class="math inline">type</span>值不同的点相连。当我们没有找到奇环的时候，<span
class="math inline">type</span>值和二分图是等价的。</p>
<p>那么仿照匈牙利的过程，我们将尝试增广的点<span
class="math inline">v</span>的<span
class="math inline">type</span>值设为<span
class="math inline">1</span>并开始增广，假设当前处理的点为<span
class="math inline">u</span>：</p>
<p>1、如果<span
class="math inline">type_u=0</span>，就代表它不在交错树中：</p>
<p>当<span
class="math inline">u</span>已经有匹配时，我们就扩展这棵交错树，将<span
class="math inline">type_u</span>的值设为<span
class="math inline">2</span>（因为其和<span
class="math inline">type</span>值为<span
class="math inline">1</span>的<span
class="math inline">v</span>相邻），并将<span
class="math inline">type_{match_u}</span>的值设为<span
class="math inline">1</span>（同理）。这时我们就可以把<span
class="math inline">match_u</span>塞进队列里了，如果能够沿着<span
class="math inline">match_u</span>找到增广路的话我们就可以让<span
class="math inline">match_u</span>匹配那个增广的点并将<span
class="math inline">u</span>与<span
class="math inline">v</span>匹配，这样就使匹配数增加了<span
class="math inline">1</span>。同时我们将<span
class="math inline">u</span>的前驱（用<span
class="math inline">pre_u</span>表示）设置为<span
class="math inline">v</span>，这是为了方便在找到增广路以后一路返回修改匹配。</p>
<p>当<span
class="math inline">u</span>并没有匹配时，我们就成功找到了一条增广路，此时沿着由<span
class="math inline">pre</span>和<span
class="math inline">match</span>连成的边一路修改就增广完成了，返回。</p>
<p>2、如果<span
class="math inline">type_u=2</span>，代表你找到了一个偶环，并没有什么用，就跳过这个点。</p>
<p>3、这里是最重点的，如果<span
class="math inline">type_u=1</span>，代表你找到了一个奇环，这就代表你的<span
class="math inline">type</span>值不再等价于二分图了，我们这个时候就可以开始“缩花”操作，将我们找到的奇环缩成一个点。让我们具体的考虑一下：</p>
<p>首先，快速找到哪些点在这个奇环中，显然<span
class="math inline">u</span>和<span
class="math inline">v</span>一定都出现在交错树上（<span
class="math inline">type</span>不为<span
class="math inline">0</span>），结合上面的那张图考虑，奇环的范围就是两个点在交错树上的链中包含的所有点，因此我们需要找到这两个点的<span
class="math inline">lca</span>，这里直接采用暴力向上跳的做法即可。</p>
<p>找到以后怎么连接<span
class="math inline">pre</span>边呢？我们参考一下文章开头的结构，可以发现此时的<span
class="math inline">lca</span>一定就是那个花中唯一的没有匹配或者匹配到外面节点的<span
class="math inline">1</span>号点。因此感性思考一下，我们应该“诱导”其他所有的点通过<span
class="math inline">pre</span>和<span
class="math inline">match</span>边一路走走到<span
class="math inline">lca</span>上，因此将除了与<span
class="math inline">lca</span>相连的<span
class="math inline">pre</span>边外其他的<span
class="math inline">pre</span>边都改为双向边，并将<span
class="math inline">u</span>和<span
class="math inline">v</span>也改成双向边即可达到这个目的。</p>
<p>最后做一点扫尾工作，我们可以通过并查集将奇环缩成一个点（因此在普通增广的时候也要考虑并查集的情况），不妨用<span
class="math inline">lca</span>做这朵花的代表。同时再考虑一下这个新点的<span
class="math inline">type</span>值应该设为什么，因为每个橙色点最多只有一个儿子（它的匹配点），因此<span
class="math inline">lca</span>一定是蓝色点，因此新点的<span
class="math inline">type</span>值为<span
class="math inline">1</span>，所以要注意将花中所有<span
class="math inline">type</span>值为<span
class="math inline">2</span>的点修改为<span
class="math inline">1</span>并且加入队列。</p>
<p>当我们找不到新的点时，本次增广失败。</p>
<p>===============分割分割================</p>
<p>以上就是一般图最大匹配的增广过程，注意在每次增广之前，<span
class="math inline">pre</span>，<span
class="math inline">type</span>以及并查集都是要初始化的。将并查集的复杂度看作常数，则每次增广至多是<span
class="math inline">O(m)</span>的，一共需要增广<span
class="math inline">O(n)</span>次，因此带花树算法的复杂度和匈牙利一样，都是<span
class="math inline">O(nm)</span>，当然，在实践中带花树算法跑得一般会比理论上界快很多。</p>
<p>相信在熟练理解带花树的过程后一定能写出代码，因此为了不对读者造成思维定式影响这里就不贴代码了。完结撒花~</p>
</body>
</html>
