<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span class="math inline">\rm
upd</span>：是我假了…这题没有爆精…大家要记得这道题是相对误差<span
class="math inline">10^{-6}</span>…感谢@foreverlasting的指正。</p>
<p><del>题是好题，可是标算爆精是怎么回事…要写的和标算一毛一样才能过。</del></p>
<p><del>各位要写的话过了前5个点就当过了吧…</del></p>
<h3 id="题意">题意</h3>
<p>你有<span class="math inline">n</span>张牌，每张牌上有一个<span
class="math inline">1\sim
m</span>的点数，你每次随机选出两张<strong>不同</strong>的牌<span
class="math inline">A</span>和<span
class="math inline">B</span>，并将<span
class="math inline">A</span>的点数变为<span
class="math inline">B</span>的点数。求将所有牌的点数变成一样的期望步数。用<span
class="math inline">double</span>输出。<span class="math inline">n\leq
10^9</span>，<span class="math inline">m\leq 10^5</span>。</p>
<h3 id="题解">题解</h3>
<p>那首先有个挺显然的想法是枚举最终变成了哪种牌，那么所有牌就变成了是这种牌与不是这种牌两类。我们这么计算这种情况的贡献：</p>
<p>假如若干步以后，是这种牌的数量变为<span
class="math inline">0</span>，则这种情况的贡献为<span
class="math inline">0</span>。 否则，若干步以后是这种牌的数量变为<span
class="math inline">n</span>，则这种情况的贡献为<span
class="math inline">发生的概率*步数</span>。</p>
<p>那么只要把每种牌的这个答案加起来就好了。</p>
<p>现在我们要解决的问题是：有两种牌，第一种有<span
class="math inline">i</span>张，第二种有<span
class="math inline">n-i</span>张，问最终全变为第一种牌的贡献。</p>
<p>很显然当<span class="math inline">n</span>固定的时候，答案只和<span
class="math inline">i</span>有关。于是我们将其记为<span
class="math inline">f_i</span>。</p>
<p>在计算<span
class="math inline">f_i</span>之前，我们先来计算辅助数组<span
class="math inline">g</span>。其中<span
class="math inline">g_i</span>表示有两种牌，第一种有<span
class="math inline">i</span>张，第二种有<span
class="math inline">n-i</span>张，问最终全变为第一种牌的<strong>概率</strong>。</p>
<p>怎么求<span class="math inline">g_i</span>呢？首先边界条件有<span
class="math inline">g_0=0</span>，<span
class="math inline">g_n=1</span>，再来考虑一般的情况。</p>
<p>我们来考虑一下第一次对牌数有影响的操作。假如<span
class="math inline">A</span>是第一种牌，<span
class="math inline">B</span>是第二种牌，那么第一种牌数<span
class="math inline">-1</span>；假如<span
class="math inline">A</span>是第二种牌，<span
class="math inline">B</span>是第一种牌，那么第一种牌数<span
class="math inline">+1</span>。显然这两种情况的方案数是一样的，于是可以得出<span
class="math inline">i</span>会等概率变成<span
class="math inline">i-1</span>或<span
class="math inline">i+1</span>，于是就可以得到一个简单的式子：</p>
<p><span class="math display">
g_i=\frac{1}{2}(g_{i-1}+g_{i+1})
</span></p>
<p>于是移项得到：</p>
<p><span class="math display">
g_{i+1}=2*g_i-g_{i-1}
</span></p>
<p>可以发现每一项都依赖前两项，于是我们设<span
class="math inline">g_1=x</span>，则可计算出<span
class="math inline">g_2=2*x</span>，<span
class="math inline">g_3=3*x</span>，<span
class="math inline">\dots</span>，那么显然我们可以猜想<span
class="math inline">g_i=i*x</span>，可以通过归纳法证明其是成立的。</p>
<p>于是得到<span class="math inline">g_n=n*x=1</span>，解得<span
class="math inline">x=\frac{1}{n}</span>。</p>
<p>因此当第一种牌数为<span
class="math inline">i</span>时，最终全变成第一种牌的概率为<span
class="math inline">\frac{i}{n}</span>。</p>
<p>现在来考虑求<span class="math inline">f_i</span>，边界条件有<span
class="math inline">f_0=0</span>，<span
class="math inline">f_n=0</span>，一般情况显然还是可以归纳成<span
class="math inline">f_{i-1}</span>和<span
class="math inline">f_{i+1}</span>的情况。不过这次还要额外考虑一些事情：</p>
<p>以变成<span
class="math inline">i-1</span>为例，首先我们枚举在几步以后变成<span
class="math inline">i-1</span>。设没有影响的操作发生概率为<span
class="math inline">p</span>，使<span
class="math inline">i</span>变为<span
class="math inline">i-1</span>的操作发生概率为<span
class="math inline">q</span>。则可得到期望额外花费的步数为：</p>
<p><span class="math display">
\sum_{j\geq 0}\Big((j+1)*p^j*q\Big)
</span></p>
<p>整理得其为<span class="math inline">\frac{q}{(1-p)^2}</span>。</p>
<p>还要注意的是由于规约到<span
class="math inline">i-1</span>的情况后成功的概率是<span
class="math inline">\frac{i-1}{n}</span>，而失败的贡献是<span
class="math inline">0</span>，因此期望步数只有<span
class="math inline">\frac{i-1}{n}</span>是有效的，贡献为<span
class="math inline">\frac{q}{(1-p)^2}*\frac{i-1}{n}</span>。</p>
<p>对于<span class="math inline">i+1</span>的情况，<span
class="math inline">p</span>和<span
class="math inline">q</span>是一样的，因此贡献为<span
class="math inline">\frac{q}{(1-p)^2}*\frac{i+1}{n}</span>。两者相加为<span
class="math inline">\frac{q}{(1-p)^2}*\frac{2*i}{n}</span>。</p>
<p>可以计算得<span
class="math inline">1-p=\frac{2*i*(n-i)}{n*(n-1)}</span>，<span
class="math inline">q=\frac{i*(n-i)}{n*(n-1)}</span>。于是原式可化简为：</p>
<p><span class="math display">
\frac{n-1}{2*(n-i)}
</span></p>
<p>因此可以得到：</p>
<p><span class="math display">
f_i=\frac{1}{2}(f_{i-1}+f_{i+1})+\frac{n-1}{2*(n-i)}
</span></p>
<p>移项可得：</p>
<p><span class="math display">
f_{i+1}=2*f_i-f_{i-1}-\frac{n-1}{n-i}
</span></p>
<p>依然设<span class="math inline">f_1=x</span>，则<span
class="math inline">f_2=2*x-\frac{n-1}{n-1}</span>，<span
class="math inline">f_3=3*x-2*\frac{n-1}{n-1}-\frac{n-1}{n-2}</span>，<span
class="math inline">\dots</span>，依然可以通过观察和归纳法证明：</p>
<p><span class="math display">
f_i=i*x-\sum_{j=1}^{i-1}\Big((i-j)*\frac{n-1}{n-j}\Big)
</span></p>
<p>那么对于<span class="math inline">f_n</span>：</p>
<p><span class="math display">
f_n=n*x-\sum_{j=1}^{n-1}\Big((n-j)*\frac{n-1}{n-j}\Big)=0
</span></p>
<p>可解得<span class="math inline">x=\frac{(n-1)*(n-1)}{n}</span>。</p>
<p>于是继续对<span class="math inline">f_i</span>的式子进行化简：</p>
<p><span class="math display">
f_i=i*\frac{(n-1)*(n-1)}{n}-i*(n-1)*\Big(\sum_{j=1}^{i-1}\frac{1}{n-j}\Big)+(n-1)*\Big(\sum_{j=1}^{i-1}\frac{j}{n-j}\Big)
</span></p>
<p>我们设<span class="math inline">H_i</span>为调和数，即<span
class="math inline">H_i=\sum_{j=1}^{i}\frac{1}{j}</span>，则第二项等于：</p>
<p><span class="math display">
-i*(n-1)*(H_{n-1}-H_{n-i})
</span></p>
<p>继续推导第三项：</p>
<p><span class="math display">
(n-1)*\Big(\sum_{j=1}^{i-1}\frac{j}{n-j}\Big)
</span></p>
<p><span class="math display">
(n-1)*\Big(\sum_{j=1}^{i-1}\big(\frac{n}{n-j}-1\big)\Big)
</span></p>
<p><span class="math display">
(n-1)*n*\Big(\sum_{j=1}^{i-1}\frac{1}{n-j}\Big)-(n-1)*(i-1)
</span></p>
<p><span class="math display">
(n-1)*n*(H_{n-1}-H_{n-i})-(n-1)*(i-1)
</span></p>
<p>将三项合并，最终得到：</p>
<p><span class="math display">
f_i=i*\frac{(n-1)*(n-1)}{n}+(n-1)*(n-i)*(H_{n-1}-H_{n-i})-(n-1)*(i-1)
</span></p>
<p>那么问题来了，<span class="math inline">n</span>那么大，<span
class="math inline">H_n</span>怎么求呢？标算的做法是将小的调和数预处理，大的用<span
class="math inline">H_x\simeq \ln x+\gamma</span>来近似，其中<span
class="math inline">\gamma</span>为欧拉常数。<del>但是不知道为啥标算的<span
class="math inline">\gamma</span>取的是<span
class="math inline">0.57</span>…不过实测下来就算预处理前<span
class="math inline">2^{20}</span>的调和数以及用较精确的欧拉常数后面的误差也在<span
class="math inline">10^{-7}</span>左右…再乘以一个大常数算答案精度堪忧。</del></p>
<p>这里再提供一个精度靠谱复杂度也有保证的做法。注意到答案中计算贡献的调和数其实类似于倒数的后缀和，因此<span
class="math inline">i</span>较小的时候显然可以预处理。可以设一个阈值<span
class="math inline">T</span>，预处理前<span
class="math inline">T</span>个后缀和，剩下的数不会超过<span
class="math inline">\frac{n}{T}</span>个，可以用分段打表暴力处理。由于查询量不是很大，打表的间隔可以取大一点减少代码长度。</p>
<p>还有由于答案有点大最好开<span class="math inline">long\
double</span>或者自己写精度更高的类型…<del>不过反正标算都爆精了这些好像也是后话了。</del>这么好的题为什么不取模呢，用第二种做法就很靠谱了。</p>
</body>
</html>
