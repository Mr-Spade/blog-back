<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: transparent;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>之前在多项式里面讲过这个…不过感觉很不严谨啊。现在我们就来严谨的说明一波这个科技到底是怎么来的。</p>
<p>常系数齐次线性递推是指这样一个问题，给你一个数<span
class="math inline">k</span>，接着对于<span
class="math inline">i=1,2,...,k</span>，给出<span
class="math inline">a_i</span>，代表递推的系数。再对于<span
class="math inline">i=0,1,2,...,k-1</span>，给出<span
class="math inline">f_i</span>作为初始值，对于<span
class="math inline">i\geq k</span>，数列<span
class="math inline">f</span>满足：</p>
<p><span class="math display">
f_i=\sum_{j=1}^k a_j*f_{i-j}
</span></p>
<p>最后给你一个数<span class="math inline">n</span>，需要求出<span
class="math inline">f_n</span>。<span
class="math inline">n</span>的范围很大。</p>
<p>在<span
class="math inline">k</span>比较小的时候，显然可以直接用矩阵快速幂来解决，转移矩阵如下：</p>
<p>$$</p>
<p>A=</p>
<p>$$</p>
<p>如此一来，如果向量<span
class="math inline">v=(f_i,f_{i+1},\cdots,f_{i+k-1})^T</span>，那么<span
class="math inline">Av=(f_{i+1},f_{i+2},\cdots,f_{i+k})^T</span>，于是只要计算<span
class="math inline">A^n</span>即可，复杂度<span
class="math inline">O(k^3\log n)</span>。</p>
<p>但是如果<span class="math inline">k=10^3</span>，甚至<span
class="math inline">k=10^5</span>，那么就无法使用矩阵快速幂了。我们来思考一下怎么样让线性递推更快。</p>
<p>为了方便，我们设向量<span class="math inline">\widehat
v=(f_0,f_1,...,f_{k-1})</span>。</p>
<p>我们考虑假设我们能够构造一个以矩阵为参数的多项式<span
class="math inline">g</span>，满足：</p>
<p><span class="math display">
\sum_{i=0}^kg_iA^i=0
</span></p>
<p>那么显然我们可以把<span class="math inline">A^n</span>用<span
class="math inline">A^0,A^1,...,A^{k-1}</span>线性表示出来——我们只需要计算<span
class="math inline">A^n\bmod
g</span>即可，此处的取模应为多项式取模，假设取模以后得到的多项式为<span
class="math inline">r</span>，于是我们有：</p>
<p><span class="math display">
A^n=\sum_{i=0}^{k-1}r_iA^i
</span></p>
<p>但是实际上我们不需要保留矩阵，我们只是想知道<span
class="math inline">(A^n\widehat
v)_0</span>，因此这个式子实际上可以转化为：</p>
<p><span class="math display">
(A^n\widehat v)_0=\sum_{i=0}^{k-1}r_i(A^i\widehat v)_0
</span></p>
<p>而对于任意的<span class="math inline">i</span>，我们有<span
class="math inline">(A^i\widehat v)_0=f_i</span>，因此：</p>
<p><span class="math display">
f_n=\sum_{i=0}^{k-1}r_if_i
</span></p>
<p>于是我们只要求<span class="math inline">x^n\bmod
g</span>，再将前<span
class="math inline">k</span>项已知的值代入即可计算，复杂度<span
class="math inline">O(k\log k\log n)</span>。</p>
<p>说得好听，那<span class="math inline">g</span>到底该怎么求呢？</p>
<p>前方大量线性代数和数学证明出没。</p>
<p>为了方便，现在起我们在没有说明的情况下，默认矩阵的规模为<span
class="math inline">n\times n</span>。</p>
<p>引理<span class="math inline">1</span>：对于任意一个满秩的矩阵<span
class="math inline">A</span>，复数域内恰好存在<span
class="math inline">n</span>个数<span
class="math inline">\lambda</span>，满足<span
class="math inline">\det(\lambda I-A)=0</span>。</p>
<p>证明：恰好存在<span class="math inline">n</span>个<span
class="math inline">\lambda</span>是很容易证明的，考虑将<span
class="math inline">\det(\lambda I-A)</span>看做一个以<span
class="math inline">\lambda</span>为参数的多项式，显然它是一个<span
class="math inline">n+1</span>次多项式，那么它在复数域内应该有<span
class="math inline">n</span>个根，同时要注意这里可能会有重根，但实际上这是没有关系的，不过我感觉具体的证明有点繁琐，所以就不放在这里了。一个比较直观的理解是你可以对输入进行很小的随机扰动使其没有重根，这不影响我们接下来的证明。</p>
<p>upd:严谨的证明请看<a
href="https://www.cnblogs.com/Mr-Spade/p/13695472.html">这里</a>。</p>
<p>引理<span class="math inline">2</span>：对于某个满足<span
class="math inline">\det(\lambda I-A)=0</span>的<span
class="math inline">\lambda</span>，存在一个对应的非零向量<span
class="math inline">v</span>，使得<span class="math inline">(\lambda
I-A)v=0</span>。并且对于所有<span class="math inline">n</span>个<span
class="math inline">\lambda</span>，他们对应的<span
class="math inline">n</span>个<span
class="math inline">v</span>是线性无关的。</p>
<p>证明：我们先来证明这样的<span
class="math inline">v</span>是存在的。我们求<span
class="math inline">v</span>的过程其实就等价于解<span
class="math inline">(\lambda
I-A)v=0</span>这个线性方程组，然而这个矩阵的行列式为<span
class="math inline">0</span>因此它是不满秩的，这意味着这个方程一定存在多解。如此一来，零向量就不可能是它的唯一解，因此我们一定可以找到这样的一个非零向量<span
class="math inline">v</span>。</p>
<p>接着，我们再来证明任意一对<span
class="math inline">v</span>不可能线性相关，注意这不代表<span
class="math inline">n</span>个<span
class="math inline">v</span>是线性无关的，因此这只是一个子问题。采用反证法，我们假设存在<span
class="math inline">\lambda_1</span>，<span
class="math inline">\lambda_2</span>，使得<span
class="math inline">(\lambda_1 I-A)v=0</span>且<span
class="math inline">(\lambda_2 I-A)v=0</span>，则我们有：</p>
<p><span class="math display">
(\lambda_1 I-A)v-(\lambda_2 I-A)v=0
</span></p>
<p>等价于：</p>
<p><span class="math display">
(\lambda_1 I-\lambda_2 I)v=(\lambda_1-\lambda_2)Iv=0
</span></p>
<p>因为<span class="math inline">\lambda_1\neq
\lambda_2</span>，因此在两边除以<span
class="math inline">\lambda_1-\lambda_2</span>，得到：</p>
<p><span class="math display">
Iv=0
</span></p>
<p>而<span class="math inline">Iv=v</span>，这就推出了<span
class="math inline">v</span>是零向量。然而<span
class="math inline">v</span>不是零向量，于是这就与前提矛盾，于是得证。</p>
<p>最后来证明<span class="math inline">n</span>个<span
class="math inline">v</span>都是线性无关的。采用反证法，不失一般性，我们假设：</p>
<p><span class="math display">
v_n=\sum_{i=1}^{n-1}k_iv_i
</span></p>
<p>其中<span class="math inline">k_i</span>为某特定常数。因为任意<span
class="math inline">(\lambda I-A)v=0</span>，于是我们有：</p>
<p><span class="math display">
(\lambda_n I-A)v_n-\sum_{i=1}^{n-1}\Big((\lambda_i I-A)k_iv_i\Big)=0
</span></p>
<p>再推导一下：</p>
<p><span class="math display">
\lambda_n Iv_n-\sum_{i=1}^{n-1}\Big(\lambda_i
Ik_iv_i\Big)+A(\sum_{i=1}^{n-1}k_iv_i)-Av_n=0
</span></p>
<p>由于<span
class="math inline">v_n=\sum_{i=1}^{n-1}k_iv_i</span>，后两项可以抵消，再将第一项转化一下，得：</p>
<p><span class="math display">
\sum_{i=1}^{n-1}\Big(\lambda_n
Ik_iv_i\Big)-\sum_{i=1}^{n-1}\Big(\lambda_i
Ik_iv_i\Big)=\sum_{i=1}^{n-1}\Big((\lambda_n-\lambda_i) Ik_iv_i\Big)=0
</span></p>
<p>由于<span
class="math inline">Iv=v</span>，因此我们消去单位矩阵，得到：</p>
<p><span class="math display">
\sum_{i=1}^{n-1}\Big((\lambda_n-\lambda_i)k_iv_i\Big)=0
</span></p>
<p>于是我们得到了前<span
class="math inline">n-1</span>个向量也是线性相关的，以此类推，我们可以推到前<span
class="math inline">2</span>个向量也是线性相关的，然而这和我们之前证明出的结论矛盾，于是推翻了假设。我们证明了<span
class="math inline">n</span>个<span
class="math inline">v</span>是线性无关的。</p>
<p>引理<span class="math inline">3</span>：<span
class="math inline">\prod_{i=1}^n(\lambda_i I-A)=0</span>。</p>
<p>证明：我们不妨证明这个矩阵乘以任意向量都为<span
class="math inline">0</span>，这和它是零矩阵是等价的（比较显然）。我们已知<span
class="math inline">n</span>个<span
class="math inline">v_i</span>都是线性无关的，那么对于任意向量<span
class="math inline">\widehat v</span>，它一定可以表示为<span
class="math inline">\sum_{i=1}^n k_iv_i</span>，其中<span
class="math inline">k_i</span>表示某一特定的常数。于是我们得到：</p>
<p><span class="math display">
\Big(\prod_{i=1}^n(\lambda_i I-A)\Big)\widehat
v=\sum_{i=1}^n\bigg(k_i\Big(\prod_{i=1}^n(\lambda_i I-A)\Big)v_i\bigg)
</span></p>
<p>我们只需要证明任意<span
class="math inline">\Big(\prod_{i=1}^n(\lambda_i
I-A)\Big)v=0</span>即可，考虑这个<span
class="math inline">\prod</span>的顺序是可以交换的，因为<span
class="math inline">(\lambda_1 I-A)(\lambda_2
I-A)=\lambda_1\lambda_2I-\lambda_1 A-\lambda_2A+A^2=(\lambda_2
I-A)(\lambda_1 I-A)</span>。那么不妨考虑将与<span
class="math inline">v</span>对应的<span class="math inline">(\lambda
I-A)</span>放到最后，先与<span
class="math inline">v</span>相乘，于是就得到了零向量，零向量乘以任意矩阵都会得到零向量，于是就证明了引理。</p>
<p>通过这三个引理，我们再进行深一步的思考。其实我们我们已经得到了一个满足条件的<span
class="math inline">g</span>（把<span
class="math inline">A</span>看作未知数）：</p>
<p><span class="math display">
\prod_{i=1}^n(\lambda_i I -A)
</span></p>
<p>然而直接求解需要我们求出所有的特征值<span
class="math inline">\lambda</span>，这很不可行。不妨来考虑这个多项式的下面两个特点：</p>
<p><span class="math inline">1</span>、这是一个<span
class="math inline">n+1</span>次的多项式。</p>
<p><span class="math inline">2</span>、最高次的系数为<span
class="math inline">1</span>，并且可以很方便的求出其所有零点，即<span
class="math inline">\lambda_1</span>、<span
class="math inline">\lambda_2</span>、<span
class="math inline">\cdots</span>、<span
class="math inline">\lambda_n</span>。</p>
<p>同时我们可以知道我们只要找到一个满足上述条件的多项式，则这个多项式一定和<span
class="math inline">\prod_{i=1}^n(\lambda_i I -A)</span>相等。</p>
<p>仔细思考一下有没有什么之前提到的多项式满足这个条件。</p>
<p>有没有电光一闪的感觉？</p>
<p><span class="math display">
\det(\lambda I-A)
</span></p>
<p>没错就是它，次数界相同，零点也完全相同，只不过未知数换成了<span
class="math inline">\lambda</span>而已。</p>
<p>至此我们完成了我们的证明，<span class="math inline">\det(\lambda
I-A)</span>就是合法的满足<span
class="math inline">g(A)=0</span>的多项式<span
class="math inline">g</span>。</p>
<p>最后我们来回头解决线性递推问题。考虑手膜<span
class="math inline">\lambda I-A</span>的行列式多项式：</p>
<p>$$</p>
<p>I-A=</p>
<p>$$</p>
<p>显然只有最后一行需要变换，稍微手推一下，发现最后一行最后一个数最终就是：</p>
<p><span class="math display">
\lambda-\sum_{i=1}^k\frac{a_i}{\lambda^{k-i}}
</span></p>
<p>接着需要乘以<span
class="math inline">\lambda^{k-1}</span>得到最终的行列式，就是：</p>
<p><span class="math display">
\lambda^k-\sum_{i=1}^ka_i*\lambda^{i-1}
</span></p>
<p>其实结论还是非常简单的…</p>
<p>参考链接：<a
href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4723">shadowice1984的博客</a>
感谢这篇文章的作者让我了解了这个黑科技。</p>
</body>
</html>
